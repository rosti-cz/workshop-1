<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Mostage - Custom Presentation</title>
  </head>
  <body>
    <div id="app"></div>

    <script type="module">const config = {
  "element": "#app",
  "theme": "dark",
  "scale": 1,
  "transition": {
    "type": "horizontal",
    "easing": "ease-in-out"
  },
  "urlHash": true,
  "centerContent": {
    "vertical": true,
    "horizontal": true
  },
  "header": {
    "content": "",
    "position": "top-left",
    "showOnFirstSlide": false
  },
  "footer": {
    "content": "",
    "position": "bottom-left",
    "showOnFirstSlide": true
  },
  "plugins": {
    "SlideNumber": {
      "enabled": true,
      "position": "bottom-right",
      "format": "current/total"
    },
    "Controller": {
      "enabled": true,
      "position": "bottom-center"
    },
    "Confetti": {
      "enabled": true,
      "particleCount": 50,
      "size": {
        "min": 5,
        "max": 15
      },
      "duration": 4000,
      "delay": 50
    }
  }
};
config.content = `# Roští Workshop

## Stacky

#### Kontejnerový webhosting

---

## Problém

#### Mám aplikaci v docker image a:

* nechci řešit hardware,
* nechci řešit infrastrukturu,
* mám docker-compose.yml,
* chci ho co nejrychleji dostat online.

---

## Co je to Stack

* Stack je prostor pro běh kontejnerů,
* kontejnery se definují pomocí docker-compose.yml formátu,
* stack řeší reverzní proxy a HTTPS,
* stack je automaticky zálohovaný do jiné lokality,
* je to pořád web-hosting, není to určené pro všechno.

---

## Aplikace vs Stacky

#### Aplikace

* Společné prostředí pro mnoho programovacích jazyků.
* Uživatel má systém, do kterého nainstaluje svůj projekt.
* Roští musí ke každému jazyku přistupovat individuálně.
* Sdílené databáze.

#### Stacky

* Prostředí pro provozování kontejnerů.
* Všechno je kontejner včetně našich nástrojů.
* Roští řeší všechny jazyky stejným způsobem.
* Dedikované databáze.

---

## Pod kapotou Stacku

* Stack běží na minimálním systému - Alpine Linux s Dockerem.
* Do tohoto systému není přímý přístup.
* Všechno ostatní je kontejner.

![Stack](data:image/png;base64,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)

---

## Zálohování

* Zálohuje se snapshot celého kontejneru jednou za den.
* Obnovuje se tedy obsah celého /,
* včetně /srv a /var/lib/docker.

* Ideální ale je používat bind a ne Docker volumes,
* a všechna data držet v /srv/stack.

---

## Výchozí kontejnery

#### Management

* Poskytuje web terminál a SSH,
* slouží k oddělení uživatele od systému,
* umožňuje upravit prostředí pro debugging podle potřeby.

#### Traefik

* Routování mezi kontejnery
* podle domény
* nebo cesty.
* Traefik automaticky hledá první exposed port.

#### Welcome

* Ukázkový kontejner.

---

## Webové rozhraní

#### Přes webovou administraci je možné:

* Sledovat stav kontejnerů,
* pracovat s terminálem na úrovni hosta, kde běží Docker,
* kontrolovat logy,
* nastavovat SSH přístupy,
* reverzní proxy,
* spravovat snapshoty (brzy),
* měnit množství přidělených prostředků,
* a spravovat docker registry.

---

## Nasazení Ghost

* Pouze compose file.

---

## Update

* Pull+Up tlačítko spustí:
  * \`docker compose pull\`
  * \`docker compose up -d\`
* Watchtower dělá pull+up automaticky

---

## Domény

* Roští není registrátor.
* Doménu je potřeba registrovat a pak buď
  * k nám namířit NS záznamy
  * nebo konkrétní A/AAAA záznamy.
* Pokud k nám namíříte NS záznamy:
  * Je nutné přidat zónu v sekci DNS,
  * jsme schopni automaticky měnit IP adresy, pokud to bude potřeba.

---

## Nasazení custom kódu

* Kód,
* Dockerfile,
* workflow.

* Pull+Up URL volá pull+up po zavolání tohoto odkazu bez přihlášení (pro CI/CD)

---

## Bonus: migrace aplikace pod stack

* Všechny aplikace jsou kontejnery,
* postavené na společném image nazvaném Runtime.
* Runtime obsahuje to co dělá mgm, traefik i prostředí pro samotný kód.

* Compose file,
* nastavení hesla pro SSH,
* zkopírování kódu.

---

## Bonus: Přístup do databází přes Adminer a phpMyAdmin

* Adminer i PHPMyAdmin fungují s databázemi uvnitř stacků.
* Je potřeba exportovat port databáze.
* a použít IP adresu stacku jako hostname.

---

## Konec

<!-- confetti -->
`;
config.element = "#app";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var prism = { exports: {} };
var hasRequiredPrism;
function requirePrism() {
  if (hasRequiredPrism) return prism.exports;
  hasRequiredPrism = 1;
  (function(module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var Prism2 = (function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _2 = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_2.util.type(o)) {
              case "Object":
                id = _2.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id] = clone;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone[key] = deepClone(o[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id = _2.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                /** @type {Array} */
                /** @type {any} */
                o.forEach(function(v2, i) {
                  clone[i] = deepClone(v2, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m2 = lang.exec(element.className);
              if (m2) {
                return m2[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if (document.currentScript && document.currentScript.tagName === "SCRIPT" && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _2.util.clone(_2.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _2.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _2.languages.DFS(_2.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _2.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _2.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _2.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _2.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _2.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _2.highlightElement(element, async === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async, callback) {
          var language = _2.util.getLanguage(element);
          var grammar = _2.languages[language];
          _2.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _2.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _2.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _2.hooks.run("after-highlight", env);
            _2.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _2.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _2.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _2.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_2.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_2.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _2.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _2.tokenize(env.code, env.grammar);
          _2.hooks.run("after-tokenize", env);
          return Token.stringify(_2.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name, callback) {
            var hooks = _2.hooks.all;
            hooks[name] = hooks[name] || [];
            hooks[name].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name, env) {
            var callbacks = _2.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _2;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify(e, language);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _2.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j2 = 0; j2 < patterns.length; ++j2) {
            if (rematch && rematch.cause == token + "," + j2) {
              return;
            }
            var patternObj = patterns[j2];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j2,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _2;
        }
        if (!_2.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_2.highlight(code, _2.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _2;
      }
      var script = _2.util.currentScript();
      if (script) {
        _2.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _2.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_2.manual) {
          _2.highlightAll();
        }
      }
      if (!_2.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _2;
    })(_self);
    if (module.exports) {
      module.exports = Prism2;
    }
    if (typeof commonjsGlobal !== "undefined") {
      commonjsGlobal.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined2(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism2.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading…";
      var FAILURE_MESSAGE = function(status, message) {
        return "✖ Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m2 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m2) {
          var start = Number(m2[1]);
          var comma = m2[2];
          var end = m2[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre = (
          /** @type {HTMLPreElement} */
          env.element
        );
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code, language);
          Prism2.util.setLanguage(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text.split(/\r\n?|\n/g);
                var start = range[0];
                var end = range[1] == null ? lines.length : range[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text;
              Prism2.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism2.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  })(prism);
  return prism.exports;
}
var prismExports = requirePrism();
const Prism$1 = /* @__PURE__ */ getDefaultExportFromCjs(prismExports);
(function(Prism2) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism2.languages.markdown = Prism2.languages.extend("markup", {});
  Prism2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism2.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [
      {
        // Prefixed by 4 spaces or 1 tab and preceded by an empty line
        pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
        lookbehind: true,
        alias: "keyword"
      },
      {
        // ```optional language
        // code block
        // ```
        pattern: /^```[\s\S]*?^```$/m,
        greedy: true,
        inside: {
          "code-block": {
            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
            lookbehind: true
          },
          "code-language": {
            pattern: /^(```).+/,
            lookbehind: true
          },
          "punctuation": /```/
        }
      }
    ],
    "title": [
      {
        // title 1
        // =======
        // title 2
        // -------
        pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
        alias: "important",
        inside: {
          punctuation: /==+$|--+$/
        }
      },
      {
        // # title 1
        // ###### title 6
        pattern: /(^\s*)#.+/m,
        lookbehind: true,
        alias: "important",
        inside: {
          punctuation: /^#+|#+$/
        }
      }
    ],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token !== inside) {
        Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside];
      }
    });
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "markdown" && env.language !== "md") {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === "string") {
        return;
      }
      for (var i = 0, l3 = tokens.length; i < l3; i++) {
        var token = tokens[i];
        if (token.type !== "code") {
          walkTokens(token.content);
          continue;
        }
        var codeLang = token.content[1];
        var codeBlock = token.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
          var alias = "language-" + lang;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism2.hooks.add("wrap", function(env) {
    if (env.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i = 0, l3 = env.classes.length; i < l3; i++) {
      var cls = env.classes[i];
      var match = /language-(.+)/.exec(cls);
      if (match) {
        codeLang = match[1];
        break;
      }
    }
    var grammar = Prism2.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
        var id = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env.attributes["id"] = id;
        Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id);
          if (ele) {
            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint = String.fromCodePoint || String.fromCharCode;
  function textContent(html) {
    var text = html.replace(tagPattern, "");
    text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code) {
      code = code.toLowerCase();
      if (code[0] === "#") {
        var value;
        if (code[1] === "x") {
          value = parseInt(code.slice(2), 16);
        } else {
          value = Number(code.slice(1));
        }
        return fromCodePoint(value);
      } else {
        var known = KNOWN_ENTITY_NAMES[code];
        if (known) {
          return known;
        }
        return m2;
      }
    });
    return text;
  }
  Prism2.languages.md = Prism2.languages.markdown;
})(Prism);
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [
            {
              pattern: /^=/,
              alias: "attr-equals"
            },
            {
              pattern: /^(\s*)["']|["']$/,
              lookbehind: true
            }
          ]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [
    {
      pattern: /&[\da-z]{1,8};/i,
      alias: "named-entity"
    },
    /&#x?[\da-f]{1,8};/i
  ]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(
        /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
        "i"
      ),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              /"|'/
            ]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [
            {
              pattern: /(^\$\(\([\s\S]+)\)\)/,
              lookbehind: true
            },
            /^\$\(\(/
          ],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not “foo {”
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    // Highlight parameter names as variables
    "parameter": {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      // → No expansion (so no “inside”).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // “Normal” string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "parameter",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ];
  var inside = insideString.variable[1].inside;
  for (var i = 0; i < toBeCopied.length; i++) {
    inside[toBeCopied[i]] = Prism2.languages.bash[toBeCopied[i]];
  }
  Prism2.languages.sh = Prism2.languages.bash;
  Prism2.languages.shell = Prism2.languages.bash;
})(Prism);
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
      lookbehind: true
    }
  ],
  "keyword": [
    {
      pattern: /((?:^|\})\s*)catch\b/,
      lookbehind: true
    },
    {
      pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: true
    }
  ],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(
      /(^|[^\w$])/.source + "(?:" + // constant
      (/NaN|Infinity/.source + "|" + // binary integer
      /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
      /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
      /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
      /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
      /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
    ),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [
    {
      pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }
  ],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  );
}
Prism.languages.js = Prism.languages.javascript;
var prismTypescript = {};
var hasRequiredPrismTypescript;
function requirePrismTypescript() {
  if (hasRequiredPrismTypescript) return prismTypescript;
  hasRequiredPrismTypescript = 1;
  (function(Prism2) {
    Prism2.languages.typescript = Prism2.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    });
    Prism2.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      // keywords that have to be followed by an identifier
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      // This is for `import type *, {}`
      /\btype\b(?=\s*(?:[\{*]|$))/
    );
    delete Prism2.languages.typescript["parameter"];
    delete Prism2.languages.typescript["literal-property"];
    var typeInside = Prism2.languages.extend("typescript", {});
    delete typeInside["class-name"];
    Prism2.languages.typescript["class-name"].inside = typeInside;
    Prism2.languages.insertBefore("typescript", "function", {
      "decorator": {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: {
          "at": {
            pattern: /^@/,
            alias: "operator"
          },
          "function": /^[\s\S]+/
        }
      },
      "generic-function": {
        // e.g. foo<T extends "bar" | "baz">( ...
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: true,
        inside: {
          "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          "generic": {
            pattern: /<[\s\S]+/,
            // everything after the first <
            alias: "class-name",
            inside: typeInside
          }
        }
      }
    });
    Prism2.languages.ts = Prism2.languages.typescript;
  })(Prism);
  return prismTypescript;
}
requirePrismTypescript();
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
(function(Prism2) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
class SyntaxHighlighter {
  constructor(config = {}) {
    this.isInitialized = false;
    this.config = {
      lineNumbers: false,
      containerClass: "syntax-highlight",
      showLanguage: false,
      ...config
    };
  }
  /**
   * Get singleton instance
   */
  static getInstance(config) {
    if (!SyntaxHighlighter.instance) {
      SyntaxHighlighter.instance = new SyntaxHighlighter(config);
    }
    return SyntaxHighlighter.instance;
  }
  /**
   * Initialize the highlighter
   */
  initialize() {
    if (this.isInitialized) return;
    this.isInitialized = true;
  }
  /**
   * Highlight code with specified language
   */
  highlightCode(code, language) {
    this.initialize();
    if (!code?.trim() || !language?.trim()) {
      return this.escapeHtml(code || "");
    }
    const normalizedLang = this.normalizeLanguage(language);
    if (!this.isLanguageSupported(normalizedLang)) {
      console.warn(`Language "${normalizedLang}" not supported`);
      return this.escapeHtml(code);
    }
    try {
      const highlighted = Prism$1.highlight(
        code,
        Prism$1.languages[normalizedLang],
        normalizedLang
      );
      return this.wrapCode(highlighted, normalizedLang);
    } catch (error) {
      console.error(`Highlighting failed for "${normalizedLang}":`, error);
      return this.escapeHtml(code);
    }
  }
  /**
   * Highlight all code blocks in container
   */
  highlightAll(container) {
    this.initialize();
    const codeBlocks = container.querySelectorAll(
      'pre code[class*="language-"]'
    );
    codeBlocks.forEach((block) => this.highlightCodeBlock(block));
    this.highlightInlineCode(container);
  }
  /**
   * Highlight inline code elements with syntax highlighting
   */
  highlightInlineCode(container) {
    const inlineCodeElements = container.querySelectorAll("code:not(pre code)");
    inlineCodeElements.forEach((element) => {
      const code = element.textContent || "";
      if (!code.trim()) return;
      const dataLang = element.getAttribute("data-language") || "";
      try {
        const highlighted = this.highlightCode(code, dataLang);
        element.innerHTML = highlighted;
        element.classList.add("inline-code-highlighted");
      } catch (error) {
        console.warn(`Failed to highlight inline code: ${code}`, error);
      }
    });
  }
  /**
   * Update configuration
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Reset to default configuration
   */
  reset() {
    this.config = {
      lineNumbers: false,
      containerClass: "syntax-highlight",
      showLanguage: false
    };
  }
  // Private methods
  isLanguageSupported(language) {
    return language in Prism$1.languages;
  }
  normalizeLanguage(language) {
    return language?.toLowerCase().trim() || "text";
  }
  escapeHtml(text) {
    const htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;"
    };
    return text.replace(/[&<>"']/g, (char) => htmlEscapes[char] || char);
  }
  wrapCode(highlightedCode, language) {
    let wrapped = highlightedCode;
    if (this.config.showLanguage) {
      wrapped = `<div class="language-label">${language}</div>${wrapped}`;
    }
    if (this.config.containerClass) {
      wrapped = `<div class="${this.config.containerClass}">${wrapped}</div>`;
    }
    return wrapped;
  }
  highlightCodeBlock(block) {
    const className = block.className;
    const languageMatch = className.match(/language-(\w+)/);
    if (!languageMatch) return;
    const language = languageMatch[1];
    const code = block.textContent || "";
    if (!code.trim()) return;
    const highlighted = this.highlightCode(code, language);
    block.innerHTML = highlighted;
  }
}
SyntaxHighlighter.getInstance();
class PluginBase {
  constructor() {
    this.styleElement = null;
    this.enabled = true;
  }
  /**
   * Check if plugin is enabled
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Set plugin enabled state
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Check if plugin is enabled and return early if not
   * This should be called at the beginning of init() method
   */
  checkEnabled() {
    if (!this.enabled) {
      return false;
    }
    return true;
  }
  /**
   * Inject CSS styles into the document
   * @param styles CSS content to inject
   * @param dataAttribute Unique data attribute to prevent duplicate injection
   */
  injectStyles(styles2, dataAttribute) {
    if (document.querySelector(`[data-mostage-${dataAttribute}]`)) return;
    this.styleElement = document.createElement("style");
    this.styleElement.setAttribute(`data-mostage-${dataAttribute}`, "true");
    this.styleElement.textContent = styles2;
    document.head.appendChild(this.styleElement);
  }
  /**
   * Clean up injected styles
   */
  cleanupStyles() {
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  /**
   * Clean up DOM elements
   * @param elements Array of elements to remove
   */
  cleanupElements(...elements) {
    elements.forEach((element) => {
      if (element) {
        element.remove();
      }
    });
  }
}
const styles$3 = ".mostage-confetti-container{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;overflow:hidden}.mostage-confetti-particle{position:absolute;border-radius:50%;animation:confetti-fall linear forwards;box-shadow:0 0 6px #0000004d}@keyframes confetti-fall{0%{opacity:1;transform:translateY(0) rotate(0)}to{opacity:0;transform:translateY(100vh) rotate(360deg)}}.mostage-confetti-particle:nth-child(3n){border-radius:0;transform:rotate(45deg)}.mostage-confetti-particle:nth-child(5n){border-radius:0;width:8px!important;height:20px!important}.mostage-confetti-particle:nth-child(7n){border-radius:50% 0}";
class ConfettiPlugin extends PluginBase {
  constructor() {
    super(...arguments);
    this.name = "Confetti";
    this.confettiContainer = null;
    this.confettiSlides = /* @__PURE__ */ new Set();
  }
  init(mo, config = {}) {
    this.mo = mo;
    this.config = {
      enabled: true,
      particleCount: 50,
      colors: [
        "#ff6b6b",
        "#4ecdc4",
        "#45b7d1",
        "#96ceb4",
        "#feca57",
        "#ff9ff3",
        "#54a0ff"
      ],
      size: {
        min: 5,
        max: 15
      },
      duration: 4e3,
      delay: 50,
      ...config
    };
    if (!this.checkEnabled()) {
      return;
    }
    this.injectStyles(styles$3, "confetti-styles");
    this.createConfettiContainer();
    this.parseSlidesForConfetti();
    this.setupSlideListener();
  }
  createConfettiContainer() {
    this.confettiContainer = document.createElement("div");
    this.confettiContainer.className = "mostage-confetti-container";
    this.confettiContainer.style.pointerEvents = "none";
    document.body.appendChild(this.confettiContainer);
  }
  parseSlidesForConfetti() {
    const slides = this.mo.getSlides();
    slides.forEach((slide, index) => {
      if (slide.content.includes("<!-- confetti -->")) {
        this.confettiSlides.add(index);
      }
    });
  }
  setupSlideListener() {
    this.mo.on("slidechange", (event) => {
      const currentSlide = event.currentSlide;
      if (this.confettiSlides.has(currentSlide)) {
        const transitionDuration = this.mo.config.transition?.duration || 300;
        const delay = transitionDuration + (this.config.delay || 100);
        setTimeout(() => {
          this.triggerConfetti();
        }, delay);
      }
    });
  }
  triggerConfetti() {
    if (!this.confettiContainer || !this.config.enabled) return;
    this.confettiContainer.innerHTML = "";
    for (let i = 0; i < (this.config.particleCount || 50); i++) {
      this.createConfettiParticle();
    }
    setTimeout(() => {
      if (this.confettiContainer) {
        this.confettiContainer.innerHTML = "";
      }
    }, this.config.duration || 3e3);
  }
  createConfettiParticle() {
    if (!this.confettiContainer) return;
    const particle = document.createElement("div");
    particle.className = "mostage-confetti-particle";
    const colors = this.config.colors || [
      "#ff6b6b",
      "#4ecdc4",
      "#45b7d1",
      "#96ceb4",
      "#feca57",
      "#ff9ff3",
      "#54a0ff"
    ];
    const color = colors[Math.floor(Math.random() * colors.length)];
    const minSize = this.config.size?.min || 5;
    const maxSize = this.config.size?.max || 15;
    const size = Math.random() * (maxSize - minSize) + minSize;
    const startX = Math.random() * window.innerWidth;
    const endX = startX + (Math.random() - 0.5) * 200;
    const rotation = Math.random() * 360;
    const rotationSpeed = (Math.random() - 0.5) * 720;
    const fallSpeed = Math.random() * 2 + 1;
    particle.style.backgroundColor = color;
    particle.style.width = `${size}px`;
    particle.style.height = `${size}px`;
    particle.style.left = `${startX}px`;
    particle.style.top = "-10px";
    particle.style.transform = `rotate(${rotation}deg)`;
    particle.style.animationDuration = `${fallSpeed}s`;
    this.confettiContainer.appendChild(particle);
    requestAnimationFrame(() => {
      particle.style.transform = `translate(${endX - startX}px, ${window.innerHeight + 20}px) rotate(${rotation + rotationSpeed}deg)`;
    });
  }
  destroy() {
    this.cleanupElements(this.confettiContainer);
    this.cleanupStyles();
    this.confettiContainer = null;
  }
}
const __vite_glob_0_0$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ConfettiPlugin,
  default: ConfettiPlugin
}, Symbol.toStringTag, { value: "Module" }));
const styles$2 = ".mostage-controller{position:fixed;z-index:1000;display:flex;gap:10px}.mostage-controller-bottom-right{bottom:20px;right:20px}.mostage-controller-bottom-left{bottom:20px;left:20px}.mostage-controller-bottom-center{bottom:20px;left:50%;transform:translate(-50%)}.mostage-btn{width:60px;height:60px;border:none;border-radius:3px;background-color:#000000b3;color:#fff;font-size:32px;font-weight:700;cursor:pointer;transition:all .2s ease;display:flex;align-items:center;justify-content:center;opacity:.5}.mostage-btn:hover{background-color:#000000e6;opacity:1}.mostage-btn:disabled{opacity:.5;cursor:not-allowed;transform:none}.mostage-btn:disabled:hover{background-color:#0006;transform:none}@media screen and (min-width: 481px) and (max-width: 768px){.mostage-controller{bottom:1rem;gap:.5rem}.mostage-btn{width:50px;height:50px;font-size:24px;opacity:.8}}@media screen and (max-width: 480px){.mostage-controller{bottom:.8rem;gap:.3rem}.mostage-btn{width:44px;height:44px;font-size:24px;opacity:.9}}@media screen and (min-width: 1024px){.mostage-controller{bottom:2rem;gap:1rem}.mostage-btn{width:65px;height:65px;font-size:24px;opacity:.5}}@media (hover: none) and (pointer: coarse){.mostage-btn{min-width:44px;min-height:44px;opacity:.9}}.mostage-btn:focus{outline:2px solid var(--mostage-primary-color, #667eea);outline-offset:2px}";
class ControllerPlugin extends PluginBase {
  constructor() {
    super(...arguments);
    this.name = "Controller";
    this.controller = null;
    this.firstBtn = null;
    this.prevBtn = null;
    this.overviewBtn = null;
    this.nextBtn = null;
    this.lastBtn = null;
  }
  init(mo, config = {}) {
    this.config = {
      enabled: true,
      position: "bottom-center",
      ...config
    };
    if (!this.checkEnabled()) {
      return;
    }
    this.injectStyles(styles$2, "controller-styles");
    this.createController(mo);
  }
  createController(mo) {
    this.controller = document.createElement("div");
    this.controller.className = `mostage-controller mostage-controller-${this.config.position}`;
    this.controller.innerHTML = `
      <button class="mostage-btn controller-first">|‹</button>
      <button class="mostage-btn controller-prev">‹</button>
      <button class="mostage-btn controller-overview">⊞</button>
      <button class="mostage-btn controller-next">›</button>
      <button class="mostage-btn controller-last">›|</button>
    `;
    this.firstBtn = this.controller.querySelector(
      ".controller-first"
    );
    this.prevBtn = this.controller.querySelector(
      ".controller-prev"
    );
    this.overviewBtn = this.controller.querySelector(
      ".controller-overview"
    );
    this.nextBtn = this.controller.querySelector(
      ".controller-next"
    );
    this.lastBtn = this.controller.querySelector(
      ".controller-last"
    );
    this.firstBtn.addEventListener("click", () => mo.goToSlide(0));
    this.prevBtn.addEventListener("click", () => mo.previousSlide());
    this.overviewBtn.addEventListener("click", () => mo.toggleOverview());
    this.nextBtn.addEventListener("click", () => mo.nextSlide());
    this.lastBtn.addEventListener(
      "click",
      () => mo.goToSlide(mo.getTotalSlides() - 1)
    );
    mo.on("slidechange", (event) => {
      this.updateButtonStates(event.currentSlide, event.totalSlides);
    });
    this.updateButtonStates(mo.getCurrentSlide(), mo.getTotalSlides());
    document.body.appendChild(this.controller);
  }
  updateButtonStates(currentSlide, totalSlides) {
    if (this.firstBtn && this.prevBtn && this.overviewBtn && this.nextBtn && this.lastBtn) {
      this.firstBtn.disabled = currentSlide === 0;
      this.prevBtn.disabled = currentSlide === 0;
      this.nextBtn.disabled = currentSlide === totalSlides - 1;
      this.lastBtn.disabled = currentSlide === totalSlides - 1;
    }
  }
  destroy() {
    this.cleanupElements(this.controller);
    this.cleanupStyles();
    this.controller = null;
    this.firstBtn = null;
    this.prevBtn = null;
    this.overviewBtn = null;
    this.nextBtn = null;
    this.lastBtn = null;
  }
}
const __vite_glob_0_1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ControllerPlugin,
  default: ControllerPlugin
}, Symbol.toStringTag, { value: "Module" }));
const styles$1 = ".mostage-progress-bar{position:fixed;left:0;right:0;z-index:1000;height:var(--progress-height, 4px);background-color:#0000001a}.mostage-progress-top{top:0}.mostage-progress-bottom{bottom:0}.mostage-progress-fill{height:100%;width:0;background-color:var(--progress-color, #007acc);transition:width .3s ease}@media screen and (max-width: 768px){.mostage-progress-bar{height:8px!important}}@media screen and (min-width: 1024px){.mostage-progress-bar{height:10px!important}}";
class ProgressBarPlugin extends PluginBase {
  constructor() {
    super(...arguments);
    this.name = "ProgressBar";
    this.progressBar = null;
  }
  init(mo, config = {}) {
    this.config = {
      enabled: true,
      position: "bottom",
      color: "#007acc",
      height: "12px",
      ...config
    };
    if (!this.checkEnabled()) {
      return;
    }
    this.injectStyles(styles$1, "progress-styles");
    this.createProgressBar();
    this.updateProgress(mo.getCurrentSlide(), mo.getTotalSlides());
    mo.on("slidechange", (event) => {
      this.updateProgress(event.currentSlide, event.totalSlides);
    });
  }
  createProgressBar() {
    this.progressBar = document.createElement("div");
    this.progressBar.className = `mostage-progress-bar mostage-progress-${this.config.position}`;
    this.progressBar.innerHTML = '<div class="mostage-progress-fill"></div>';
    this.progressBar.style.backgroundColor = "rgba(0,0,0,0.1)";
    this.progressBar.style.height = this.config.height;
    const fill = this.progressBar.querySelector(
      ".mostage-progress-fill"
    );
    if (fill) {
      fill.style.backgroundColor = this.config.color;
      fill.style.height = "100%";
    }
    document.body.appendChild(this.progressBar);
  }
  updateProgress(current, total) {
    if (!this.progressBar) return;
    const fill = this.progressBar.querySelector(
      ".mostage-progress-fill"
    );
    if (fill) {
      const percentage = (current + 1) / total * 100;
      fill.style.width = `${percentage}%`;
    }
  }
  destroy() {
    this.cleanupElements(this.progressBar);
    this.cleanupStyles();
    this.progressBar = null;
  }
}
const __vite_glob_0_2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProgressBarPlugin,
  default: ProgressBarPlugin
}, Symbol.toStringTag, { value: "Module" }));
const styles = ".mostage-slide-number{position:fixed;z-index:999;width:80px;height:60px;border-radius:3px;background-color:#000000b3;color:#fff;font-size:24px;display:flex;align-items:center;justify-content:center}.mostage-slide-number-bottom-right{bottom:20px;right:20px}.mostage-slide-number-bottom-left{bottom:20px;left:20px}.mostage-slide-number-bottom-center{bottom:20px;left:50%;transform:translate(-50%)}@media screen and (min-width: 481px) and (max-width: 768px){.mostage-slide-number{bottom:1rem;width:60px;height:50px;font-size:12px}.mostage-slide-number-bottom-right{right:1rem}.mostage-slide-number-bottom-left{left:1rem}}@media screen and (max-width: 480px){.mostage-slide-number{bottom:.8rem;width:55px;height:44px;font-size:11px}.mostage-slide-number-bottom-right{right:.8rem}.mostage-slide-number-bottom-left{left:.8rem}}@media screen and (max-width: 360px){.mostage-slide-number{display:none}}@media screen and (min-width: 1024px){.mostage-slide-number{bottom:2rem;width:80px;height:65px;font-size:16px}.mostage-slide-number-bottom-right{right:2rem}.mostage-slide-number-bottom-left{left:2rem}}";
class SlideNumberPlugin extends PluginBase {
  constructor() {
    super(...arguments);
    this.name = "SlideNumber";
    this.slideNumberElement = null;
  }
  init(mo, config = {}) {
    this.config = {
      enabled: true,
      position: "bottom-right",
      format: "current/total",
      ...config
    };
    if (!this.checkEnabled()) {
      return;
    }
    this.injectStyles(styles, "slide-number-styles");
    this.createSlideNumber();
    this.updateSlideNumber(mo.getCurrentSlide(), mo.getTotalSlides());
    mo.on("slidechange", (event) => {
      this.updateSlideNumber(event.currentSlide, event.totalSlides);
    });
  }
  createSlideNumber() {
    this.slideNumberElement = document.createElement("div");
    this.slideNumberElement.className = `mostage-slide-number mostage-slide-number-${this.config.position}`;
    document.body.appendChild(this.slideNumberElement);
  }
  updateSlideNumber(current, total) {
    if (this.slideNumberElement) {
      let text = this.config.format.replace("current", (current + 1).toString()).replace("total", total.toString());
      this.slideNumberElement.textContent = text;
    }
  }
  destroy() {
    this.cleanupElements(this.slideNumberElement);
    this.cleanupStyles();
    this.slideNumberElement = null;
  }
}
const __vite_glob_0_3$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SlideNumberPlugin,
  default: SlideNumberPlugin
}, Symbol.toStringTag, { value: "Module" }));
const _PluginService = class _PluginService {
  /**
   * Initialize plugin auto-discovery system
   */
  static initialize() {
    if (this.initialized) return this.plugins;
    const pluginContext = /* @__PURE__ */ Object.assign({
      "../plugins/confetti/index.ts": __vite_glob_0_0$1,
      "../plugins/controller/index.ts": __vite_glob_0_1$1,
      "../plugins/progress-bar/index.ts": __vite_glob_0_2$1,
      "../plugins/slide-number/index.ts": __vite_glob_0_3$1
    });
    Object.entries(pluginContext).forEach(([path, module]) => {
      const exports = module;
      const PluginClass = exports.default || Object.values(exports).find(
        (exp) => typeof exp === "function" && exp.name && exp.name.endsWith("Plugin")
      );
      if (PluginClass && typeof PluginClass === "function") {
        try {
          const instance = new PluginClass();
          this.plugins[instance.name] = PluginClass;
        } catch (error) {
          console.warn(`Failed to register plugin from ${path}:`, error);
        }
      }
    });
    this.initialized = true;
    return this.plugins;
  }
  /**
   * Get all registered plugins
   */
  static getPlugins() {
    if (!this.initialized) {
      this.initialize();
    }
    return this.plugins;
  }
  /**
   * Get a specific plugin by name
   */
  static getPlugin(name) {
    const plugins2 = this.getPlugins();
    return plugins2[name];
  }
  /**
   * Get list of available plugin names
   */
  static getAvailablePlugins() {
    return Object.keys(this.getPlugins());
  }
  /**
   * Load a plugin with configuration
   */
  static async loadPlugin(name) {
    try {
      const PluginClass = this.getPlugin(name);
      if (!PluginClass) {
        throw new PluginNotFoundError(`Plugin '${name}' not found`);
      }
      const plugin = new PluginClass();
      this.loadedPlugins.set(name, plugin);
      return plugin;
    } catch (error) {
      throw new PluginLoadError(
        `Failed to load plugin '${name}': ${error instanceof Error ? error.message : "Unknown error"}`,
        name
      );
    }
  }
  /**
   * Unload a plugin
   */
  static unloadPlugin(name) {
    const plugin = this.loadedPlugins.get(name);
    if (plugin) {
      try {
        if (plugin.destroy) {
          plugin.destroy();
        }
        this.loadedPlugins.delete(name);
      } catch (error) {
        console.error(`Error destroying plugin '${name}':`, error);
      }
    }
  }
  /**
   * Get all loaded plugins
   */
  static getLoadedPlugins() {
    return Array.from(this.loadedPlugins.values());
  }
  /**
   * Check if a plugin is loaded
   */
  static isPluginLoaded(name) {
    return this.loadedPlugins.has(name);
  }
  /**
   * Enable a plugin
   */
  static enablePlugin(name) {
    const plugin = this.loadedPlugins.get(name);
    if (plugin && plugin.setEnabled) {
      plugin.setEnabled(true);
    }
  }
  /**
   * Disable a plugin
   */
  static disablePlugin(name) {
    const plugin = this.loadedPlugins.get(name);
    if (plugin && plugin.setEnabled) {
      plugin.setEnabled(false);
    }
  }
  /**
   * Get plugin statistics
   */
  static getPluginStats() {
    return {
      total: Object.keys(this.plugins).length,
      loaded: this.loadedPlugins.size,
      available: Object.keys(this.plugins)
    };
  }
};
_PluginService.plugins = {};
_PluginService.loadedPlugins = /* @__PURE__ */ new Map();
_PluginService.initialized = false;
let PluginService = _PluginService;
class PluginError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = this.constructor.name;
  }
}
class PluginLoadError extends PluginError {
  constructor(message, pluginName) {
    super(message, "PLUGIN_LOAD_ERROR");
    this.pluginName = pluginName;
  }
}
class PluginNotFoundError extends PluginError {
  constructor(pluginName) {
    super(`Plugin '${pluginName}' not found`, "PLUGIN_NOT_FOUND");
  }
}
const plugins = PluginService.initialize();
const __vite_glob_0_0 = '/* Dark Theme - Mostage */\n\n:root {\n  --mostage-bg-color: #0f0f23;\n  --mostage-text-color: #e2e8f0;\n  --mostage-primary-color: #667eea;\n  --mostage-secondary-color: #764ba2;\n  --mostage-accent-color: #fbb6ce;\n  --mostage-border-color: #4a5568;\n  --mostage-highlight-color: #63b3ed;\n}\n\n.mostage-container {\n  background: linear-gradient(135deg, var(--mostage-bg-color) 0%, #1a1a2e 100%);\n  color: var(--mostage-text-color);\n  font-family:\n    "Inter",\n    -apple-system,\n    BlinkMacSystemFont,\n    "Segoe UI",\n    "Roboto",\n    sans-serif;\n  min-height: 100vh;\n}\n\n.mostage-slide {\n  background: rgba(26, 32, 44, 0.9);\n  color: var(--mostage-text-color);\n  border: 1px solid rgba(74, 85, 104, 0.6);\n  box-shadow:\n    0 20px 40px rgba(0, 0, 0, 0.3),\n    0 8px 16px rgba(0, 0, 0, 0.2);\n  backdrop-filter: blur(10px);\n}\n\n.mostage-slide h1,\n.mostage-slide h2,\n.mostage-slide h3,\n.mostage-slide h4,\n.mostage-slide h5,\n.mostage-slide h6 {\n  color: #ffffff;\n  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.mostage-slide h1 {\n  background: linear-gradient(\n    135deg,\n    var(--mostage-primary-color) 0%,\n    var(--mostage-secondary-color) 100%\n  );\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n}\n\n.mostage-slide pre {\n  background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);\n  border: 1px solid var(--mostage-border-color);\n  padding: 0.5rem 1.5rem;\n}\n\n.mostage-slide blockquote {\n  color: #cbd5e0;\n  background: rgba(74, 85, 104, 0.3);\n  border-left-color: var(--mostage-primary-color);\n}\n\n.mostage-slide a {\n  color: #90cdf4;\n}\n\n.mostage-slide a:hover {\n  color: var(--mostage-highlight-color);\n}\n\n.mostage-progress-bar {\n  background: rgba(26, 32, 44, 0.8);\n  backdrop-filter: blur(10px);\n}\n\n.mostage-progress-fill {\n  background: linear-gradient(\n    90deg,\n    var(--mostage-primary-color) 0%,\n    var(--mostage-secondary-color) 100%\n  );\n}\n\n.mostage-slide-number {\n  background: rgba(26, 32, 44, 0.9);\n  color: #cbd5e0;\n  border-color: var(--mostage-border-color);\n}\n\n.mostage-btn {\n  background: rgba(26, 32, 44, 0.9);\n  color: #cbd5e0;\n  border-color: var(--mostage-border-color);\n}\n\n.mostage-btn:hover {\n  background: rgba(45, 55, 72, 0.9);\n  color: var(--mostage-text-color);\n  border-color: rgba(113, 128, 150, 0.8);\n}\n\n.mostage-overview-slide {\n  background: rgba(26, 32, 44, 0.9);\n  border: 2px solid var(--mostage-border-color);\n  color: var(--mostage-text-color);\n}\n\n.mostage-overview-slide:hover {\n  background: rgba(45, 55, 72, 0.9);\n  border-color: rgba(113, 128, 150, 0.8);\n}\n\n.mostage-overview-slide.active {\n  border-color: var(--mostage-primary-color);\n}\n\n/* Table background for dark theme */\n.mostage-slide table {\n  color: var(--mostage-text-color);\n}\n\n.mostage-slide th,\n.mostage-slide td {\n  border: 1px solid var(--mostage-border-color);\n}\n\n/* Dark Theme Header and Footer */\n.mostage-container .mostage-header {\n  background: linear-gradient(\n    135deg,\n    var(--mostage-primary-color) 0%,\n    var(--mostage-secondary-color) 100%\n  );\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n}\n';
const __vite_glob_0_1 = '/* Dracula Theme - Mostage (Official Colors) */\n:root {\n  --mostage-bg-color: #282a36; /* Background */\n  --mostage-text-color: #f8f8f2; /* Foreground */\n  --mostage-primary-color: #bd93f9; /* Purple */\n  --mostage-secondary-color: #ff79c6; /* Pink */\n  --mostage-accent-color: #ffb86c; /* Orange */\n  --mostage-border-color: #6272a4; /* Comment */\n  --mostage-highlight-color: #50fa7b; /* Green */\n  --mostage-cyan-color: #8be9fd; /* Cyan */\n}\n\n.mostage-container {\n  background: var(--mostage-bg-color);\n  color: var(--mostage-text-color);\n  font-family:\n    "Inter",\n    -apple-system,\n    BlinkMacSystemFont,\n    "Segoe UI",\n    "Roboto",\n    sans-serif;\n  min-height: 100vh;\n}\n\n.mostage-slide {\n  background: var(--mostage-bg-color);\n  color: var(--mostage-text-color);\n  border: 1px solid var(--mostage-border-color);\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n}\n\n.mostage-slide h1,\n.mostage-slide h2,\n.mostage-slide h3,\n.mostage-slide h4,\n.mostage-slide h5,\n.mostage-slide h6 {\n  color: var(--mostage-primary-color);\n}\n\n.mostage-slide h1 {\n  color: var(--mostage-secondary-color);\n}\n\n.mostage-slide pre {\n  background: var(--mostage-bg-color);\n  border: 1px solid var(--mostage-border-color);\n  padding: 0.5rem 1.5rem;\n}\n\n.mostage-slide blockquote {\n  color: var(--mostage-border-color);\n  background: var(--mostage-bg-color);\n  border-left-color: var(--mostage-primary-color);\n}\n\n.mostage-slide a {\n  color: var(--mostage-cyan-color);\n}\n\n.mostage-slide a:hover {\n  color: var(--mostage-highlight-color);\n}\n\n.mostage-progress-bar {\n  background: var(--mostage-bg-color);\n}\n\n.mostage-progress-fill {\n  background: var(--mostage-primary-color);\n}\n\n.mostage-slide-number {\n  background: var(--mostage-bg-color);\n  color: var(--mostage-text-color);\n  border-color: var(--mostage-border-color);\n}\n\n.mostage-btn {\n  background: var(--mostage-bg-color);\n  color: var(--mostage-text-color);\n  border-color: var(--mostage-border-color);\n}\n\n.mostage-btn:hover {\n  background: var(--mostage-border-color);\n  color: var(--mostage-secondary-color);\n  border-color: var(--mostage-primary-color);\n}\n\n.mostage-overview-slide {\n  background: var(--mostage-bg-color);\n  border: 2px solid var(--mostage-border-color);\n  color: var(--mostage-text-color);\n}\n\n.mostage-overview-slide:hover {\n  background: var(--mostage-border-color);\n  border-color: var(--mostage-primary-color);\n}\n\n.mostage-overview-slide.active {\n  border-color: var(--mostage-primary-color);\n}\n';
const __vite_glob_0_2 = '/* Light Theme - Mostage */\n:root {\n  --mostage-bg-color: #fdfbfb;\n  --mostage-text-color: #2d3748;\n  --mostage-primary-color: #667eea;\n  --mostage-secondary-color: #764ba2;\n  --mostage-accent-color: #e53e3e;\n  --mostage-border-color: #e2e8f0;\n  --mostage-highlight-color: #5a67d8;\n}\n\n.mostage-container {\n  background: linear-gradient(135deg, var(--mostage-bg-color) 0%, #ebedee 100%);\n  color: var(--mostage-text-color);\n  font-family:\n    "Inter",\n    -apple-system,\n    BlinkMacSystemFont,\n    "Segoe UI",\n    "Roboto",\n    sans-serif;\n  min-height: 100vh;\n}\n\n.mostage-slide {\n  background: rgba(255, 255, 255, 0.9);\n  color: var(--mostage-text-color);\n  border: 1px solid rgba(226, 232, 240, 0.8);\n  box-shadow:\n    0 20px 40px rgba(0, 0, 0, 0.05),\n    0 8px 16px rgba(0, 0, 0, 0.03);\n  backdrop-filter: blur(10px);\n}\n\n.mostage-slide h1,\n.mostage-slide h2,\n.mostage-slide h3,\n.mostage-slide h4,\n.mostage-slide h5,\n.mostage-slide h6 {\n  color: #1a202c;\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);\n}\n\n.mostage-slide h1 {\n  background: linear-gradient(\n    135deg,\n    var(--mostage-primary-color) 0%,\n    var(--mostage-secondary-color) 100%\n  );\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n}\n\n.mostage-slide pre {\n  background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);\n  border: 1px solid var(--mostage-border-color);\n  padding: 0.5rem 1.5rem;\n}\n\n.mostage-slide blockquote {\n  color: #4a5568;\n  background: rgba(237, 242, 247, 0.3);\n  border-left-color: var(--mostage-primary-color);\n}\n\n.mostage-slide a {\n  color: var(--mostage-primary-color);\n}\n\n.mostage-slide a:hover {\n  color: var(--mostage-highlight-color);\n}\n\n.mostage-progress-bar {\n  background: rgba(255, 255, 255, 0.2);\n  backdrop-filter: blur(10px);\n}\n\n.mostage-progress-fill {\n  background: linear-gradient(\n    90deg,\n    var(--mostage-primary-color) 0%,\n    var(--mostage-secondary-color) 100%\n  );\n}\n\n.mostage-slide-number {\n  background: rgba(255, 255, 255, 0.9);\n  color: #4a5568;\n  border-color: var(--mostage-border-color);\n}\n\n.mostage-btn {\n  background: rgba(255, 255, 255, 0.9);\n  color: #4a5568;\n  border-color: var(--mostage-border-color);\n}\n\n.mostage-btn:hover {\n  background: rgba(255, 255, 255, 0.95);\n  color: var(--mostage-text-color);\n  border-color: rgba(203, 213, 224, 0.8);\n}\n\n.mostage-overview-slide {\n  background: rgba(255, 255, 255, 0.95);\n  border: 2px solid var(--mostage-border-color);\n  color: var(--mostage-text-color);\n}\n\n.mostage-overview-slide:hover {\n  background: rgba(255, 255, 255, 0.98);\n  border-color: rgba(203, 213, 224, 0.8);\n}\n\n.mostage-overview-slide.active {\n  border-color: var(--mostage-primary-color);\n}\n';
const __vite_glob_0_3 = '/* Ocean Theme - Mostage */\n:root {\n  --mostage-bg-color: #0f1419;\n  --mostage-text-color: #e6f1ff;\n  --mostage-primary-color: #00d4ff;\n  --mostage-secondary-color: #36d7b7;\n  --mostage-accent-color: #ff6b6b;\n  --mostage-border-color: #1e3a8a;\n  --mostage-highlight-color: #0ea5e9;\n}\n\n.mostage-container {\n  background: linear-gradient(135deg, var(--mostage-bg-color) 0%, #1e3a8a 100%);\n  color: var(--mostage-text-color);\n  font-family:\n    "Inter",\n    -apple-system,\n    BlinkMacSystemFont,\n    "Segoe UI",\n    "Roboto",\n    sans-serif;\n  min-height: 100vh;\n}\n\n.mostage-slide {\n  background: rgba(30, 58, 138, 0.1);\n  color: var(--mostage-text-color);\n  border: 1px solid var(--mostage-border-color);\n  backdrop-filter: blur(10px);\n}\n\n.mostage-slide h1,\n.mostage-slide h2,\n.mostage-slide h3,\n.mostage-slide h4,\n.mostage-slide h5,\n.mostage-slide h6 {\n  color: var(--mostage-primary-color);\n  text-shadow: 0 0 10px rgba(0, 212, 255, 0.3);\n}\n\n.mostage-slide h1 {\n  background: linear-gradient(\n    135deg,\n    var(--mostage-primary-color) 0%,\n    var(--mostage-secondary-color) 100%\n  );\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n}\n\n.mostage-slide pre {\n  background: #1e293b;\n  border: 1px solid var(--mostage-border-color);\n  padding: 0.5rem 1.5rem;\n}\n\n.mostage-slide blockquote {\n  color: var(--mostage-secondary-color);\n  background: rgba(54, 215, 183, 0.1);\n  border-left-color: var(--mostage-secondary-color);\n}\n\n.mostage-slide a {\n  color: var(--mostage-primary-color);\n  text-decoration: none;\n  border-bottom: 1px solid transparent;\n  transition: all 0.3s ease;\n}\n\n.mostage-slide a:hover {\n  border-bottom-color: var(--mostage-primary-color);\n  text-shadow: 0 0 5px rgba(0, 212, 255, 0.5);\n}\n\n.mostage-progress-bar {\n  background: var(--mostage-primary-color);\n  box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);\n}\n\n.mostage-progress-fill {\n  background: linear-gradient(\n    90deg,\n    var(--mostage-primary-color) 0%,\n    var(--mostage-secondary-color) 100%\n  );\n}\n\n.mostage-slide-number {\n  background: rgba(30, 58, 138, 0.8);\n  color: var(--mostage-primary-color);\n  border: 1px solid var(--mostage-border-color);\n  backdrop-filter: blur(5px);\n}\n\n.mostage-btn {\n  background: rgba(30, 58, 138, 0.8);\n  color: var(--mostage-primary-color);\n  border: 1px solid var(--mostage-border-color);\n  backdrop-filter: blur(5px);\n  transition: all 0.3s ease;\n}\n\n.mostage-btn:hover {\n  background: rgba(0, 212, 255, 0.2);\n  box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);\n}\n\n.mostage-overview-slide {\n  background: rgba(15, 20, 25, 0.9);\n  border: 2px solid var(--mostage-border-color);\n  color: var(--mostage-text-color);\n}\n\n.mostage-overview-slide:hover {\n  background: rgba(0, 212, 255, 0.1);\n  border-color: var(--mostage-primary-color);\n}\n\n.mostage-overview-slide.active {\n  border-color: var(--mostage-primary-color);\n}\n';
const __vite_glob_0_4 = '/* Rainbow Theme - Mostage (Colorful & Bright) */\n:root {\n  --mostage-bg-color: #e2e8f0; /* Background */\n  --mostage-text-color: #1e293b; /* Dark text */\n  --mostage-primary-color: #3b82f6; /* Blue */\n  --mostage-secondary-color: #8b5cf6; /* Purple */\n  --mostage-accent-color: #f59e0b; /* Orange */\n  --mostage-border-color: #e2e8f0; /* Light border */\n  --mostage-highlight-color: #10b981; /* Green */\n  --mostage-pink-color: #ec4899; /* Pink */\n  --mostage-red-color: #ef4444; /* Red */\n  --mostage-yellow-color: #eab308; /* Yellow */\n}\n\n.mostage-container {\n  background: var(--mostage-bg-color);\n  color: var(--mostage-text-color);\n  font-family:\n    "Inter",\n    -apple-system,\n    BlinkMacSystemFont,\n    "Segoe UI",\n    "Roboto",\n    sans-serif;\n  min-height: 100vh;\n}\n\n.mostage-slide {\n  background: #ffffff;\n  color: var(--mostage-text-color);\n  border: 2px solid var(--mostage-border-color);\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n}\n\n.mostage-slide h1,\n.mostage-slide h2,\n.mostage-slide h3,\n.mostage-slide h4,\n.mostage-slide h5,\n.mostage-slide h6 {\n  color: var(--mostage-primary-color);\n}\n\n.mostage-slide h1 {\n  color: var(--mostage-secondary-color);\n  background: linear-gradient(\n    135deg,\n    var(--mostage-primary-color) 0%,\n    var(--mostage-secondary-color) 50%,\n    var(--mostage-pink-color) 100%\n  );\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n}\n\n.mostage-slide h2 {\n  color: var(--mostage-pink-color);\n}\n\n.mostage-slide h3 {\n  color: var(--mostage-accent-color);\n}\n\n.mostage-slide h4 {\n  color: var(--mostage-highlight-color);\n}\n\n.mostage-slide h5 {\n  color: var(--mostage-red-color);\n}\n\n.mostage-slide h6 {\n  color: var(--mostage-yellow-color);\n}\n\n.mostage-slide pre {\n  background: #1e293b;\n  border: 1px solid var(--mostage-border-color);\n  padding: 0.5rem 1.5rem;\n}\n\n.mostage-slide blockquote {\n  color: var(--mostage-accent-color);\n  background: #fef3c7;\n  border-left: 4px solid var(--mostage-yellow-color);\n  border-radius: 0 8px 8px 0;\n}\n\n.mostage-slide a {\n  color: var(--mostage-primary-color);\n  text-decoration: none;\n  border-bottom: 2px solid transparent;\n  transition: all 0.3s ease;\n}\n\n.mostage-slide a:hover {\n  color: var(--mostage-pink-color);\n  border-bottom-color: var(--mostage-pink-color);\n}\n\n.mostage-progress-bar {\n  background: #e2e8f0;\n  border-radius: 10px;\n}\n\n.mostage-progress-fill {\n  background: linear-gradient(\n    90deg,\n    var(--mostage-primary-color) 0%,\n    var(--mostage-secondary-color) 25%,\n    var(--mostage-pink-color) 50%,\n    var(--mostage-accent-color) 75%,\n    var(--mostage-highlight-color) 100%\n  );\n  border-radius: 10px;\n}\n\n.mostage-slide-number {\n  background: var(--mostage-primary-color);\n  color: #ffffff;\n  border: 2px solid var(--mostage-secondary-color);\n  border-radius: 50%;\n}\n\n.mostage-btn {\n  background: var(--mostage-primary-color);\n  color: #ffffff;\n  border: 2px solid var(--mostage-primary-color);\n  border-radius: 8px;\n  transition: all 0.3s ease;\n}\n\n.mostage-btn:hover {\n  background: var(--mostage-secondary-color);\n  border-color: var(--mostage-secondary-color);\n  transform: translateY(-2px);\n  box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);\n}\n\n.mostage-overview-slide {\n  background: #ffffff;\n  border: 3px solid var(--mostage-border-color);\n  color: var(--mostage-text-color);\n  border-radius: 12px;\n  transition: all 0.3s ease;\n}\n\n.mostage-overview-slide:hover {\n  border-color: var(--mostage-primary-color);\n  transform: scale(1.02);\n  box-shadow: 0 8px 20px rgba(59, 130, 246, 0.2);\n}\n\n.mostage-overview-slide.active {\n  border-color: var(--mostage-secondary-color);\n  background: linear-gradient(135deg, #f8fafc 0%, #e0e7ff 100%);\n}\n';
const baseStylesCSS = '/* Mostage Base Styles - Simple & Clean */\n\n/* Reset and Base */\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\n\nbody {\n  margin: 0;\n  padding: 0;\n  font-family:\n    -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue",\n    sans-serif;\n}\n\n/* Container - Clamp-based responsive sizing with larger minimums and preferred sizes */\n.mostage-container {\n  width: 100vw;\n  height: 100vh;\n  position: relative;\n  overflow: hidden;\n  font-size: clamp(18px, 2vw, 18px);\n  line-height: 1.6;\n}\n\n.mostage-slides {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  overflow: hidden;\n}\n\n/* Slide Layout - Clamp-based responsive sizing with larger minimums and preferred sizes */\n.mostage-slide {\n  width: 100%;\n  height: 100%;\n  padding: clamp(2.5rem, 3.5vw, 3rem);\n  position: absolute;\n  top: 0;\n  left: 0;\n  /* Removed base transition to prevent conflict with JavaScript transitions */\n  overflow: auto;\n  display: block;\n}\n\n/* Background Image Support */\n.mostage-slide[style*="background-image"] {\n  background-attachment: fixed;\n}\n\n/* Ensure content is visible over background images */\n.mostage-slide-content {\n  position: relative;\n  z-index: 1;\n}\n\n/* Header and Footer Styles - Clamp-based responsive sizing with larger minimums and preferred sizes */\n.mostage-header {\n  position: fixed;\n  z-index: 1000;\n  padding: clamp(1.5rem, 2vw, 1.5rem) clamp(2.5rem, 3vw, 3rem);\n  opacity: 0;\n  animation: mostage-fade-in 0.7s ease forwards;\n}\n\n.mostage-footer {\n  position: fixed;\n  z-index: 1000;\n  padding: clamp(1.5rem, 2vw, 1.5rem) clamp(2.5rem, 3vw, 3rem);\n  opacity: 0;\n  animation: mostage-fade-in 0.7s ease forwards;\n}\n\n@keyframes mostage-fade-in {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n/* Header Position Classes */\n.mostage-header-top-left {\n  top: 0;\n  left: 0;\n}\n\n.mostage-header-top-center {\n  top: 0;\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n.mostage-header-top-right {\n  top: 0;\n  right: 0;\n}\n\n/* Footer Position Classes */\n.mostage-footer-bottom-left {\n  bottom: 0;\n  left: 0;\n}\n\n.mostage-footer-bottom-center {\n  bottom: 0;\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n.mostage-footer-bottom-right {\n  bottom: 0;\n  right: 0;\n}\n';
const typographyStylesCSS = "/* Typography - Proper Hierarchy */\n\n/* Headings - Clamp-based responsive sizing with larger minimums and preferred sizes */\n.mostage-slide h1 {\n  font-size: clamp(4rem, 5vw, 6rem);\n  font-weight: 700;\n  line-height: 1.1;\n  margin-bottom: 1.5rem;\n  color: #1a202c;\n}\n\n.mostage-slide h2 {\n  font-size: clamp(3rem, 4vw, 4.5rem);\n  font-weight: 600;\n  line-height: 1.2;\n  margin-bottom: 1.25rem;\n  color: #2d3748;\n}\n\n.mostage-slide h3 {\n  font-size: clamp(2rem, 3vw, 3rem);\n  font-weight: 600;\n  line-height: 1.3;\n  margin-bottom: 1rem;\n  color: #2d3748;\n}\n\n.mostage-slide h4 {\n  font-size: clamp(1.75rem, 2.5vw, 2.25rem);\n  font-weight: 600;\n  line-height: 1.4;\n  margin-bottom: 0.875rem;\n  color: #4a5568;\n}\n\n.mostage-slide h5 {\n  font-size: clamp(1.5rem, 2vw, 1.875rem);\n  font-weight: 600;\n  line-height: 1.4;\n  margin-bottom: 0.75rem;\n  color: #4a5568;\n}\n\n.mostage-slide h6 {\n  font-size: clamp(1.25rem, 1.5vw, 1.5rem);\n  font-weight: 600;\n  line-height: 1.2;\n  margin-bottom: 0.625rem;\n  color: #718096;\n}\n\n/* Content - Clamp-based responsive sizing with larger minimums and preferred sizes */\n.mostage-slide p {\n  font-size: clamp(1.5rem, 2vw, 1.5rem);\n  line-height: 1.6;\n  margin: 0 0 1.25rem 0;\n}\n\n/* Lists - Clamp-based responsive sizing with larger minimums and preferred sizes */\n.mostage-slide ul,\n.mostage-slide ol {\n  font-size: clamp(1.5rem, 2vw, 1.5rem);\n  line-height: 1.6;\n  margin: 0 0 1.25rem 0;\n  padding-left: 2rem;\n}\n\n.mostage-slide li {\n  margin-bottom: 0.5rem;\n}\n\n/* Nested Lists - Clamp-based responsive sizing with larger minimums and preferred sizes */\n.mostage-slide ul ul,\n.mostage-slide ol ol,\n.mostage-slide ul ol,\n.mostage-slide ol ul {\n  margin: 0.5rem 0;\n  padding-left: 2rem;\n  font-size: clamp(1.25rem, 1.5vw, 1.25rem);\n}\n\n.mostage-slide ul ul ul,\n.mostage-slide ol ol ol,\n.mostage-slide ul ol ul,\n.mostage-slide ol ul ol,\n.mostage-slide ul ul ol,\n.mostage-slide ol ol ul {\n  padding-left: 2.5rem;\n  font-size: clamp(1.125rem, 1.25vw, 1.125rem);\n}\n\n.mostage-slide li li {\n  margin-bottom: 0.375rem;\n}\n\n.mostage-slide li li li {\n  margin-bottom: 0.25rem;\n}\n\n/* List Styles */\n.mostage-slide ol {\n  list-style-type: decimal;\n}\n\n.mostage-slide ol ol {\n  list-style-type: lower-alpha;\n}\n\n.mostage-slide ol ol ol {\n  list-style-type: lower-roman;\n}\n\n.mostage-slide ol li {\n  margin-bottom: 0.5rem;\n  padding-left: 0.5rem;\n}\n\n.mostage-slide ol ol li {\n  margin-bottom: 0.375rem;\n  padding-left: 0.25rem;\n}\n\n.mostage-slide ol ol ol li {\n  margin-bottom: 0.25rem;\n  padding-left: 0.125rem;\n}\n\n.mostage-slide ul {\n  list-style-type: disc;\n}\n\n.mostage-slide ul ul {\n  list-style-type: circle;\n}\n\n.mostage-slide ul ul ul {\n  list-style-type: square;\n}\n\n/* Blockquotes - Clamp-based responsive sizing with larger minimums and preferred sizes */\n.mostage-slide blockquote {\n  display: inline-block;\n  font-size: clamp(1.5rem, 2vw, 1.5rem);\n  line-height: 1.6;\n  margin: 1.5rem 0;\n  padding: 1rem 1.5rem;\n  border-left: 4px solid currentColor;\n  background: rgba(0, 0, 0, 0.05);\n  border-radius: 0 4px 4px 0;\n}\n\n/* Code - Clamp-based responsive sizing with larger minimums and preferred sizes */\n.mostage-slide pre {\n  width: fit-content;\n  border-radius: 3px;\n  overflow: auto;\n  padding: 0.5rem 1.5rem;\n}\n\n/* Enhanced inline code with syntax highlighting */\n.mostage-slide code.inline-code-highlighted {\n  background: rgba(255, 255, 255, 0.08);\n  display: inline-block;\n  border-radius: 3px;\n  padding: 0 5px;\n}\n\n/* Links */\n.mostage-slide a {\n  color: inherit;\n  text-decoration: underline;\n  text-decoration-thickness: 1px;\n  text-underline-offset: 2px;\n  transition: opacity 0.2s ease;\n}\n\n/* Images */\n.mostage-slide img {\n  max-width: 100%;\n  height: auto;\n  border-radius: 4px;\n  margin: 1rem 0;\n}\n\n/* Tables - Clamp-based responsive sizing with larger minimums and preferred sizes */\n.mostage-slide table {\n  border-collapse: collapse;\n  margin: 1.5rem 0;\n  font-size: clamp(1.25rem, 1.5vw, 1.25rem);\n}\n\n.mostage-slide th,\n.mostage-slide td {\n  border: 1px solid rgba(0, 0, 0, 0.2);\n  padding: 0.75rem 1rem;\n}\n\n.mostage-slide th {\n  background-color: rgba(0, 0, 0, 0.05);\n  font-weight: 600;\n}\n\n.mostage-slide tbody tr:nth-child(even) {\n  background-color: rgba(0, 0, 0, 0.02);\n}\n\n.mostage-slide tbody tr:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n\n/* Text Elements */\n.mostage-slide del {\n  text-decoration: line-through;\n  opacity: 0.7;\n}\n\n.mostage-slide hr {\n  border: none;\n  height: 1px;\n  background: rgba(0, 0, 0, 0.2);\n  margin: 2rem 0;\n}\n\n.mostage-slide strong {\n  font-weight: 600;\n}\n\n.mostage-slide em {\n  font-style: italic;\n}\n";
const centerContentStylesCSS = "/* Center Content Styles - Applied when centerContent is enabled */\n\n.mostage-slide.mostage-slide-centered .mostage-slide-content {\n  transform: translateY(-5vh);\n\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n\n  padding: 2rem;\n  box-sizing: border-box;\n  overflow: auto;\n}\n\n.mostage-slide.mostage-slide-centered > * {\n  max-width: 100%;\n  width: auto;\n}\n\n.mostage-slide.mostage-slide-centered h1,\n.mostage-slide.mostage-slide-centered h2,\n.mostage-slide.mostage-slide-centered h3,\n.mostage-slide.mostage-slide-centered h4,\n.mostage-slide.mostage-slide-centered h5,\n.mostage-slide.mostage-slide-centered h6,\n.mostage-slide.mostage-slide-centered p,\n.mostage-slide.mostage-slide-centered blockquote {\n  text-align: left;\n}\n\n.mostage-slide.mostage-slide-centered ul,\n.mostage-slide.mostage-slide-centered ol {\n  text-align: left;\n}\n\n.mostage-slide.mostage-slide-centered img {\n  display: block;\n  margin: clamp(1.5rem, 2vw, 1.5rem) auto;\n}\n";
const overviewModeStylesCSS = '/* Overview Mode Styles */\n\n/* ==========================================================================\n   BASE STYLES (Desktop First)\n   ========================================================================== */\n\n.mostage-overview {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  background: var(--mostage-bg-color);\n  color: var(--mostage-text-color);\n  z-index: 2000;\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\n  gap: 30px 20px;\n  padding: 80px;\n  overflow-y: auto;\n  box-sizing: border-box;\n  align-content: start;\n  justify-content: center;\n  opacity: 0;\n  animation: overviewFadeIn 0.3s ease-out forwards;\n}\n\n@keyframes overviewFadeIn {\n  from {\n    opacity: 0;\n    transform: scale(0.95);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n\n.mostage-overview-slide {\n  width: 280px;\n  height: 180px;\n  background-color: var(--mostage-bg-color);\n  color: var(--mostage-text-color);\n  border-radius: 5px;\n  cursor: pointer;\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  border: 3px solid var(--mostage-border-color);\n  overflow: hidden;\n  position: relative;\n  transform-origin: center;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n  backdrop-filter: blur(10px);\n}\n\n/* Theme-aware background fallbacks */\n.mostage-overview-slide:not([style*="background-color"]) {\n  background-color: var(--mostage-bg-color);\n}\n\n.mostage-overview-slide::before {\n  content: "";\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  border-radius: 5px;\n  pointer-events: none;\n}\n\n.mostage-overview-slide:hover {\n  border-color: var(--mostage-primary-color);\n}\n\n.mostage-overview-slide.active {\n  border-color: var(--mostage-primary-color);\n}\n\n.mostage-overview-slide.selected {\n  border-color: var(--mostage-primary-color);\n  box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);\n}\n\n.mostage-overview-slide-number {\n  position: absolute;\n  bottom: 8px;\n  right: 8px;\n  background: var(--mostage-bg-color);\n  color: var(--mostage-text-color);\n  border: 1px solid var(--mostage-border-color);\n  padding: 4px 8px;\n  border-radius: 3px;\n  font-size: 18px;\n  font-weight: 600;\n  z-index: 10;\n  backdrop-filter: blur(5px);\n}\n\n.mostage-overview-slide-content {\n  width: 333.33%; /* Compensate for scale (100% / 0.3) */\n  height: 333.33%; /* Compensate for scale (100% / 0.3) */\n  overflow: hidden;\n  border-radius: 12px;\n  position: relative;\n  z-index: 1;\n  transform: scale(0.3);\n  transform-origin: top left;\n  padding: 2rem;\n  box-sizing: border-box;\n  background-color: inherit;\n  color: inherit;\n}\n\n/* Ensure all content inside overview slides inherits theme styles */\n.mostage-overview-slide-content * {\n  font-family: inherit;\n  line-height: inherit;\n  letter-spacing: inherit;\n}\n\n/* Apply centerContent styles to overview mode */\n.mostage-overview-slide-content.mostage-slide-centered {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  padding: 2rem;\n  box-sizing: border-box;\n  transform-origin: center center;\n}\n\n.mostage-overview-slide-content.mostage-slide-centered > * {\n  max-width: 100%;\n  width: auto;\n}\n\n.mostage-overview-slide-content.mostage-slide-centered h1,\n.mostage-overview-slide-content.mostage-slide-centered h2,\n.mostage-overview-slide-content.mostage-slide-centered h3,\n.mostage-overview-slide-content.mostage-slide-centered h4,\n.mostage-overview-slide-content.mostage-slide-centered h5,\n.mostage-overview-slide-content.mostage-slide-centered h6,\n.mostage-overview-slide-content.mostage-slide-centered p,\n.mostage-overview-slide-content.mostage-slide-centered blockquote {\n  text-align: left;\n}\n\n.mostage-overview-slide-content.mostage-slide-centered ul,\n.mostage-overview-slide-content.mostage-slide-centered ol {\n  text-align: left;\n}\n\n.mostage-overview-slide-content.mostage-slide-centered pre {\n  text-align: left;\n  max-width: 90%;\n  margin: 1rem auto;\n}\n\n.mostage-overview-slide-content.mostage-slide-centered img {\n  display: block;\n  margin: 1rem auto;\n}\n\n/* Disable all interactive elements in overview mode */\n.mostage-overview-slide-content a,\n.mostage-overview-slide-content button,\n.mostage-overview-slide-content input,\n.mostage-overview-slide-content select,\n.mostage-overview-slide-content textarea {\n  pointer-events: none;\n  cursor: default;\n}\n\n.mostage-overview-close {\n  position: fixed;\n  top: 30px;\n  right: 30px;\n  width: 50px;\n  height: 50px;\n  border: none;\n  border-radius: 50%;\n  background: rgba(255, 255, 255, 0.1);\n  color: #ffffff;\n  font-size: 24px;\n  font-weight: bold;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  backdrop-filter: blur(10px);\n  z-index: 2001;\n}\n\n.mostage-overview-close:hover {\n  background-color: rgba(255, 255, 255, 0.2);\n}\n\n/* ==========================================================================\n   RESPONSIVE STYLES\n   ========================================================================== */\n\n/* Tablet devices */\n@media screen and (min-width: 481px) and (max-width: 768px) {\n  .mostage-overview {\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    padding: 40px 20px;\n    gap: 20px 15px;\n  }\n\n  .mostage-overview-slide {\n    width: 100%;\n    aspect-ratio: 4/3;\n  }\n\n  .mostage-overview-slide-content {\n    padding: 15px;\n    font-size: 12px;\n  }\n\n  .mostage-overview-slide h1 {\n    font-size: 16px;\n  }\n\n  .mostage-overview-slide h2 {\n    font-size: 14px;\n  }\n\n  .mostage-overview-slide h3 {\n    font-size: 13px;\n  }\n\n  .mostage-overview-close {\n    top: 20px;\n    right: 20px;\n    width: 40px;\n    height: 40px;\n    font-size: 20px;\n  }\n\n  .mostage-overview-help {\n    display: none;\n  }\n}\n\n/* Mobile devices */\n@media screen and (max-width: 480px) {\n  .mostage-overview {\n    grid-template-columns: repeat(2, 1fr);\n    padding: 20px 10px 40px;\n    gap: 12px 8px;\n  }\n\n  .mostage-overview-slide {\n    width: 100%;\n  }\n\n  .mostage-overview-slide-content {\n    padding: 12px;\n    font-size: 11px;\n  }\n\n  .mostage-overview-slide h1 {\n    font-size: 14px;\n  }\n\n  .mostage-overview-slide h2 {\n    font-size: 12px;\n  }\n\n  .mostage-overview-slide h3 {\n    font-size: 11px;\n  }\n\n  .mostage-overview-close {\n    top: 15px;\n    right: 15px;\n    width: 40px;\n    height: 40px;\n    font-size: 20px;\n  }\n\n  .mostage-overview-help {\n    display: none;\n  }\n}\n\n/* Very small mobile devices - Single column */\n@media screen and (max-width: 360px) {\n  .mostage-overview {\n    grid-template-columns: 1fr;\n    padding: 15px 8px;\n    gap: 12px;\n  }\n\n  .mostage-overview-slide {\n    width: 100%;\n    max-width: 300px;\n    margin: 0 auto;\n  }\n\n  .mostage-overview-slide-content {\n    padding: 10px;\n    font-size: 10px;\n  }\n\n  .mostage-overview-slide h1 {\n    font-size: 12px;\n  }\n\n  .mostage-overview-slide h2 {\n    font-size: 11px;\n  }\n\n  .mostage-overview-slide h3 {\n    font-size: 10px;\n  }\n\n  .mostage-overview-close {\n    top: 15px;\n    right: 15px;\n    width: 35px;\n    height: 35px;\n    font-size: 18px;\n  }\n\n  .mostage-overview-help {\n    display: none;\n  }\n}\n\n/* ==========================================================================\n   ACCESSIBILITY & INTERACTIONS\n   ========================================================================== */\n\n/* Touch-friendly interactions */\n@media (hover: none) and (pointer: coarse) {\n  .mostage-overview button {\n    min-width: 44px;\n    min-height: 44px;\n    touch-action: manipulation;\n  }\n}\n\n/* Focus indicators for keyboard navigation */\n.mostage-overview button:focus {\n  outline: 2px solid var(--mostage-primary-color, #667eea);\n  outline-offset: 2px;\n}\n\n/* Footer */\n.mostage-overview-footer {\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  text-align: center;\n  padding: 7px;\n  font-size: 12px;\n  color: rgba(255, 255, 255, 0.7);\n  z-index: 2001;\n  background: var(--mostage-bg-color);\n}\n\n.mostage-overview-footer a {\n  color: #ffffff;\n  text-decoration: none;\n}\n\n.mostage-overview-footer a:hover {\n  text-decoration: underline;\n}\n';
const helpStylesCSS = "/* Help System Styles */\n\n/* ==========================================================================\n   BASE STYLES (Desktop First)\n   ========================================================================== */\n\n/* Normal Mode Help - Top Right */\n.mostage-help {\n  position: fixed;\n  top: 30px;\n  right: 30px;\n  background: rgba(0, 0, 0, 0.8);\n  color: #ffffff;\n  padding: 15px 20px;\n  border-radius: 3px;\n  font-size: 14px;\n  line-height: 1.5;\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  z-index: 3000;\n  width: 300px;\n  opacity: 0;\n  transform: translateY(-10px) scale(0.95);\n  transition:\n    opacity 0.3s ease-out,\n    transform 0.3s ease-out;\n}\n\n/* Animation classes */\n.mostage-help.fade-in {\n  opacity: 1;\n  transform: translateY(0) scale(1);\n}\n\n.mostage-help.fade-out {\n  opacity: 0;\n  transform: translateY(-10px) scale(0.95);\n}\n\n/* Overview help animation classes */\n.mostage-overview-help.fade-in {\n  opacity: 1;\n  transform: translateY(0) scale(1);\n}\n\n.mostage-overview-help.fade-out {\n  opacity: 0;\n  transform: translateY(10px) scale(0.95);\n}\n\n.mostage-help-overlay {\n  display: none;\n}\n\n.mostage-help-content {\n  position: relative;\n  background: none;\n  border-radius: 0;\n  box-shadow: none;\n  max-width: none;\n  width: auto;\n  max-height: none;\n  overflow: visible;\n  z-index: auto;\n}\n\n.mostage-help-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0 0 8px 0;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n  margin-bottom: 8px;\n}\n\n.mostage-help-header h3 {\n  margin: 0;\n  color: #007acc;\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.mostage-help-close {\n  background: none;\n  border: none;\n  font-size: 18px;\n  color: #ffffff;\n  cursor: pointer;\n  padding: 2px;\n  border-radius: 4px;\n  transition: all 0.2s ease;\n}\n\n.mostage-help-close:hover {\n  background: rgba(255, 255, 255, 0.1);\n  color: #ffffff;\n}\n\n.mostage-help-body {\n  padding: 0;\n}\n\n.mostage-help-section {\n  margin-bottom: 12px;\n}\n\n.mostage-help-section:last-child {\n  margin-bottom: 0;\n}\n\n.mostage-help-section h4 {\n  margin: 0 0 6px 0;\n  color: #ffffff;\n  font-size: 14px;\n  font-weight: 600;\n}\n\n.mostage-help-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 2px 0;\n  border-bottom: none;\n}\n\n.mostage-help-item:last-child {\n  border-bottom: none;\n}\n\n.mostage-help-description {\n  color: #e2e8f0;\n  font-size: 13px;\n}\n\n.mostage-help-keys {\n  display: flex;\n  gap: 4px;\n}\n\n.mostage-help-key {\n  background: rgba(255, 255, 255, 0.1);\n  border: 1px solid rgba(255, 255, 255, 0.3);\n  padding: 2px 6px;\n  border-radius: 4px;\n  font-family: monospace;\n  font-size: 12px;\n  color: #ffffff;\n  font-weight: 500;\n  cursor: default;\n}\n\n/* Overview Mode Help - Bottom Right */\n.mostage-overview-help {\n  position: static;\n  bottom: 30px;\n  right: 30px;\n  background: rgba(0, 0, 0, 0.8);\n  color: #ffffff;\n  padding: 15px 20px;\n  border-radius: 3px;\n  font-size: 14px;\n  line-height: 1.5;\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  z-index: 2002;\n  width: 280px;\n  opacity: 0;\n  transform: translateY(10px) scale(0.95);\n  transition:\n    opacity 0.3s ease-out,\n    transform 0.3s ease-out;\n}\n\n/* Content wrapper for overview help */\n.mostage-overview-help-content {\n  position: relative;\n  background: none;\n  border-radius: 0;\n  box-shadow: none;\n  max-width: none;\n  width: auto;\n  max-height: none;\n  overflow: visible;\n  z-index: auto;\n}\n\n/* Unified help styles - both normal and overview use the same structure */\n\n/* Header styles for both modes */\n.mostage-help-header,\n.mostage-overview-help-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0 0 8px 0;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n  margin-bottom: 8px;\n}\n\n.mostage-help-header h3,\n.mostage-overview-help-header h3 {\n  margin: 0;\n  color: #007acc;\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.mostage-help-close,\n.mostage-overview-help-close {\n  background: none;\n  border: none;\n  font-size: 18px;\n  color: #ffffff;\n  cursor: pointer;\n  padding: 2px;\n  border-radius: 4px;\n  transition: all 0.2s ease;\n}\n\n.mostage-help-close:hover,\n.mostage-overview-help-close:hover {\n  background: rgba(255, 255, 255, 0.1);\n  color: #ffffff;\n}\n\n/* Body styles for both modes */\n.mostage-help-body,\n.mostage-overview-help-body {\n  padding: 0;\n}\n\n.mostage-help-item,\n.mostage-overview-help-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 4px;\n}\n\n.mostage-help-key,\n.mostage-overview-help-key {\n  background: rgba(255, 255, 255, 0.1);\n  padding: 2px 6px;\n  border-radius: 4px;\n  font-family: monospace;\n  font-size: 12px;\n  border: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.mostage-help-description,\n.mostage-overview-help-description {\n  color: #e2e8f0;\n  font-size: 13px;\n}\n\n.mostage-help-keys,\n.mostage-overview-help-keys {\n  display: flex;\n  gap: 4px;\n}\n\n/* ==========================================================================\n   RESPONSIVE STYLES\n   ========================================================================== */\n\n/* Tablet devices */\n@media screen and (min-width: 481px) and (max-width: 768px) {\n  .mostage-help {\n    top: 20px;\n    right: 20px;\n    width: 280px;\n    font-size: 12px;\n    padding: 12px 16px;\n  }\n\n  .mostage-help-header h3 {\n    font-size: 14px;\n  }\n\n  .mostage-help-section h4 {\n    font-size: 12px;\n  }\n\n  .mostage-help-description {\n    font-size: 11px;\n  }\n\n  .mostage-help-key {\n    font-size: 10px;\n    padding: 1px 4px;\n  }\n}\n\n/* Mobile devices - Hide help by default */\n@media screen and (max-width: 480px) {\n  .mostage-help {\n    display: none;\n  }\n}\n\n/* ==========================================================================\n   ANIMATIONS\n   ========================================================================== */\n\n@keyframes helpFadeIn {\n  from {\n    opacity: 0;\n    transform: translateY(-10px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n/* ==========================================================================\n   ACCESSIBILITY & INTERACTIONS\n   ========================================================================== */\n\n/* Touch-friendly interactions */\n@media (hover: none) and (pointer: coarse) {\n  .mostage-help button,\n  .mostage-overview-help button {\n    min-width: 44px;\n    min-height: 44px;\n    touch-action: manipulation;\n  }\n}\n\n/* Focus indicators for keyboard navigation */\n.mostage-help button:focus,\n.mostage-overview-help button:focus {\n  outline: 2px solid var(--mostage-primary-color, #667eea);\n  outline-offset: 2px;\n}\n";
const responsiveStylesCSS = "/* Mostage Responsive Styles */\n\n/* ==========================================================================\n   BASE STYLES (Desktop First)\n   ========================================================================== */\n\n/* Default styles are for desktop/larger screens */\n\n/* ==========================================================================\n   TABLET DEVICES (768px and below)\n   ========================================================================== */\n\n@media screen and (max-width: 768px) {\n  .mostage-container {\n    font-size: 16px;\n    line-height: 1.5;\n    overflow-x: hidden;\n  }\n\n  .mostage-slide {\n    padding: 1rem;\n    font-size: 14px;\n    line-height: 1.6;\n    overflow-x: auto;\n    -webkit-overflow-scrolling: touch;\n    padding-bottom: 5rem; /* Space for controller */\n  }\n\n  /* Typography scaling */\n  .mostage-slide h1 {\n    font-size: 1.8rem;\n    line-height: 1.8;\n    margin-bottom: 0.5rem;\n  }\n\n  .mostage-slide h2 {\n    font-size: 1.5rem;\n    line-height: 1.8;\n    margin-bottom: 0.4rem;\n  }\n\n  .mostage-slide h3 {\n    font-size: 1.3rem;\n    line-height: 1.8;\n    margin-bottom: 0.2rem;\n  }\n\n  .mostage-slide h4 {\n    font-size: 1.1rem;\n    line-height: 1.8;\n    margin-bottom: 0.2rem;\n  }\n\n  .mostage-slide h5 {\n    font-size: 0.8rem;\n    line-height: 1.8;\n    margin-bottom: 0.2rem;\n  }\n\n  .mostage-slide h6 {\n    font-size: 0.7rem;\n    line-height: 1.8;\n    margin-bottom: 0.1rem;\n  }\n\n  .mostage-slide p {\n    font-size: 14px;\n    line-height: 1.8;\n    margin-bottom: 0.3rem;\n  }\n\n  /* Lists */\n  .mostage-slide ul,\n  .mostage-slide ol {\n    padding-left: 1.2rem;\n    margin: 0.5rem 0;\n  }\n\n  .mostage-slide li {\n    font-size: 14px;\n    line-height: 1.4;\n    margin-bottom: 0.2rem;\n  }\n\n  /* Code blocks */\n  .mostage-slide pre {\n    font-size: 12px;\n    padding: 0.8rem;\n    margin: 0.5rem 0;\n    overflow-x: auto;\n    -webkit-overflow-scrolling: touch;\n  }\n\n  /* Tables */\n  .mostage-slide table {\n    font-size: 12px;\n    width: 100%;\n    display: block;\n    overflow-x: auto;\n    -webkit-overflow-scrolling: touch;\n  }\n\n  .mostage-slide th,\n  .mostage-slide td {\n    padding: 0.3rem 0.5rem;\n    white-space: nowrap;\n  }\n\n  /* Images */\n  .mostage-slide img {\n    max-width: 100%;\n    height: auto;\n    display: block;\n    margin: 0.5rem auto;\n  }\n\n  /* Blockquotes */\n  .mostage-slide blockquote {\n    font-size: 13px;\n    padding: 0.5rem 0.8rem;\n    margin: 0.5rem 0;\n    border-left-width: 3px;\n  }\n\n  /* Header and Footer */\n  .mostage-header,\n  .mostage-footer {\n    padding: 0.5rem;\n    font-size: 12px;\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .mostage-footer {\n    bottom: 4rem;\n    position: fixed;\n    z-index: 1000;\n  }\n\n  /* Navigation */\n  .mostage-navigation {\n    font-size: 12px;\n  }\n\n  /* Touch-friendly interactions */\n  .mostage-navigation button {\n    min-width: 44px;\n    min-height: 44px;\n    touch-action: manipulation;\n  }\n}\n\n/* ==========================================================================\n   MOBILE DEVICES (480px and below)\n   ========================================================================== */\n\n@media screen and (max-width: 480px) {\n  .mostage-container {\n    font-size: 14px;\n  }\n\n  .mostage-slide {\n    padding: 0.8rem;\n    font-size: 13px;\n  }\n\n  .mostage-slide h1 {\n    font-size: 1.5rem;\n  }\n\n  .mostage-slide h2 {\n    font-size: 1.3rem;\n  }\n\n  .mostage-slide h3 {\n    font-size: 1.1rem;\n  }\n\n  .mostage-slide h4 {\n    font-size: 1rem;\n  }\n\n  .mostage-slide p {\n    font-size: 13px;\n  }\n\n  .mostage-slide pre {\n    font-size: 11px;\n    padding: 0.6rem;\n  }\n\n  .mostage-slide code {\n    font-size: 11px;\n  }\n\n  .mostage-slide table {\n    font-size: 11px;\n  }\n\n  .mostage-slide th,\n  .mostage-slide td {\n    padding: 0.2rem 0.3rem;\n  }\n\n  .mostage-slide blockquote {\n    font-size: 12px;\n    padding: 0.4rem 0.6rem;\n  }\n\n  .mostage-header,\n  .mostage-footer {\n    font-size: 11px;\n    padding: 0.3rem 1.2rem;\n  }\n}\n\n/* ==========================================================================\n   SMALL MOBILE DEVICES (320px and below)\n   ========================================================================== */\n\n@media screen and (max-width: 320px) {\n  .mostage-header,\n  .mostage-footer {\n    display: none;\n  }\n\n  .mostage-slide-number {\n    display: none;\n  }\n}\n\n/* ==========================================================================\n   HIGH DPI DISPLAYS\n   ========================================================================== */\n\n@media screen and (-webkit-min-device-pixel-ratio: 2),\n  screen and (min-resolution: 192dpi) {\n  .mostage-slide img {\n    image-rendering: -webkit-optimize-contrast;\n    image-rendering: crisp-edges;\n  }\n}\n\n/* ==========================================================================\n   ACCESSIBILITY IMPROVEMENTS\n   ========================================================================== */\n\n/* Focus indicators for keyboard navigation */\n.mostage-navigation button:focus {\n  outline: 2px solid var(--mostage-primary-color, #667eea);\n  outline-offset: 2px;\n}\n\n/* Reduced motion for users who prefer it */\n@media (prefers-reduced-motion: reduce) {\n  .mostage-slide {\n    transition: none;\n  }\n\n  .mostage-container * {\n    animation-duration: 0.01ms;\n    animation-iteration-count: 1;\n    transition-duration: 0.01ms;\n  }\n}\n\n/* High contrast mode support */\n@media (prefers-contrast: high) {\n  .mostage-slide {\n    border: 2px solid currentColor;\n  }\n\n  .mostage-slide h1,\n  .mostage-slide h2,\n  .mostage-slide h3,\n  .mostage-slide h4,\n  .mostage-slide h5,\n  .mostage-slide h6 {\n    text-decoration: underline;\n  }\n}\n\n/* ==========================================================================\n   UTILITY CLASSES\n   ========================================================================== */\n\n.mobile-only {\n  display: none;\n}\n\n@media screen and (max-width: 768px) {\n  .mobile-only {\n    display: block;\n  }\n}\n";
const textContentStylesCSS = "/* Text Content Styles - For text parser specific content */\n\n.text-content {\n  width: 100%;\n  max-width: 100%;\n}\n\n.text-heading {\n  margin: 1.5rem 0 1rem 0;\n  font-weight: 600;\n  line-height: 1.3;\n}\n\n.text-heading:first-child {\n  margin-top: 0;\n}\n\n.text-paragraph {\n  margin: 1rem 0;\n  line-height: 1.6;\n}\n\n.text-paragraph:first-child {\n  margin-top: 0;\n}\n\n.text-paragraph:last-child {\n  margin-bottom: 0;\n}\n\n.text-emphasis {\n  margin: 1.5rem 0;\n  padding: 1rem;\n  background: rgba(0, 122, 204, 0.1);\n  border-left: 4px solid var(--accent-color, #007acc);\n  border-radius: 4px;\n  font-weight: 500;\n  font-style: italic;\n}\n";
const combinedBaseStyles = [
  baseStylesCSS,
  typographyStylesCSS,
  centerContentStylesCSS,
  overviewModeStylesCSS,
  helpStylesCSS,
  responsiveStylesCSS,
  textContentStylesCSS
].join("\n");
const _ThemeService = class _ThemeService {
  /**
   * Ensure themes are initialized
   */
  static ensureInitialized() {
    if (!this.initialized) {
      this.initialize();
    }
  }
  /**
   * Initialize theme auto-discovery system
   */
  static initialize() {
    if (this.initialized) return this.availableThemes;
    const themeContext = /* @__PURE__ */ Object.assign({
      "../themes/dark.css": __vite_glob_0_0,
      "../themes/dracula.css": __vite_glob_0_1,
      "../themes/light.css": __vite_glob_0_2,
      "../themes/ocean.css": __vite_glob_0_3,
      "../themes/rainbow.css": __vite_glob_0_4
    });
    Object.entries(themeContext).forEach(([path, cssContent]) => {
      const themeName = path.replace("../themes/", "").replace(".css", "");
      this.availableThemes[themeName] = {
        name: themeName,
        cssContent
      };
    });
    this.initialized = true;
    return this.availableThemes;
  }
  /**
   * Load a theme by name with enhanced error handling
   */
  static async loadTheme(themeName) {
    try {
      this.ensureInitialized();
      const theme = this.availableThemes[themeName];
      if (!theme) {
        const availableThemes = Object.keys(this.availableThemes);
        if (availableThemes.length === 0) {
          throw new ThemeError(
            `No themes available. Theme '${themeName}' not found.`
          );
        }
        console.warn(
          `Theme '${themeName}' not found. Falling back to '${availableThemes[0]}'`
        );
        return this.loadTheme(availableThemes[0]);
      }
      if (!this.baseStylesLoaded) {
        this.loadBaseStyles();
        this.baseStylesLoaded = true;
      }
      this.removeExistingThemeStyles();
      this.injectThemeStyles(theme);
      this.currentTheme = theme;
      console.log(`Theme '${themeName}' loaded successfully`);
    } catch (error) {
      throw new ThemeLoadError(
        `Failed to load theme '${themeName}': ${error instanceof Error ? error.message : "Unknown error"}`,
        themeName
      );
    }
  }
  /**
   * Switch to a different theme
   */
  static async switchTheme(themeName) {
    await this.loadTheme(themeName);
  }
  /**
   * Get the currently loaded theme
   */
  static getCurrentTheme() {
    return this.currentTheme;
  }
  /**
   * Check if a theme is currently loaded
   */
  static isThemeLoaded(themeName) {
    return this.currentTheme?.name === themeName;
  }
  /**
   * Get all available themes
   */
  static getAvailableThemes() {
    this.ensureInitialized();
    return Object.values(this.availableThemes);
  }
  /**
   * Remove existing theme styles from DOM
   */
  static removeExistingThemeStyles() {
    const existingThemeStyles = document.querySelectorAll(
      "style[data-mostage-theme]"
    );
    existingThemeStyles.forEach((style) => style.remove());
  }
  /**
   * Inject theme styles into DOM
   */
  static injectThemeStyles(theme) {
    const styleElement = document.createElement("style");
    styleElement.setAttribute("data-mostage-theme", theme.name);
    styleElement.textContent = theme.cssContent;
    document.head.appendChild(styleElement);
  }
  /**
   * Load base styles
   */
  static loadBaseStyles() {
    if (document.querySelector("style[data-mostage-base]")) {
      return;
    }
    const styleElement = document.createElement("style");
    styleElement.setAttribute("data-mostage-base", "true");
    styleElement.textContent = combinedBaseStyles;
    document.head.appendChild(styleElement);
  }
  /**
   * Get all available themes as record
   */
  static getAvailableThemesRecord() {
    this.ensureInitialized();
    return this.availableThemes;
  }
  /**
   * Get list of available theme names
   */
  static getThemeNames() {
    this.ensureInitialized();
    return Object.keys(this.availableThemes);
  }
  /**
   * Get theme by name
   */
  static getTheme(name) {
    this.ensureInitialized();
    return this.availableThemes[name];
  }
  /**
   * Register a new theme dynamically
   */
  static registerTheme(theme) {
    this.ensureInitialized();
    this.availableThemes[theme.name] = theme;
  }
  /**
   * Check if a theme exists
   */
  static hasTheme(name) {
    this.ensureInitialized();
    return name in this.availableThemes;
  }
};
_ThemeService.availableThemes = {};
_ThemeService.baseStylesLoaded = false;
_ThemeService.initialized = false;
_ThemeService.currentTheme = null;
let ThemeService = _ThemeService;
class ThemeError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = this.constructor.name;
  }
}
class ThemeLoadError extends ThemeError {
  constructor(message, themeName) {
    super(message, "THEME_LOAD_ERROR");
    this.themeName = themeName;
  }
}
const themes = ThemeService.initialize();
const loadTheme = ThemeService.loadTheme.bind(ThemeService);
const getAvailableThemes = ThemeService.getThemeNames.bind(ThemeService);
function L() {
  return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
}
var O = L();
function G(l3) {
  O = l3;
}
var E = { exec: () => null };
function h(l3, e = "") {
  let t = typeof l3 == "string" ? l3 : l3.source, n = { replace: (r, i) => {
    let s = typeof i == "string" ? i : i.source;
    return s = s.replace(m.caret, "$1"), t = t.replace(r, s), n;
  }, getRegex: () => new RegExp(t, e) };
  return n;
}
var m = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (l3) => new RegExp(`^( {0,3}${l3})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}#`), htmlBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}<(?:[a-z].*>|!--)`, "i") }, xe = /^(?:[ \t]*(?:\n|$))+/, be = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Re = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, C = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Oe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, j = /(?:[*+-]|\d{1,9}[.)])/, se = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, ie = h(se).replace(/bull/g, j).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Te = h(se).replace(/bull/g, j).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), F = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, we = /^[^\n]+/, Q = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, ye = h(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Q).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Pe = h(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, j).getRegex(), v = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", U = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Se = h("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", U).replace("tag", v).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), oe = h(F).replace("hr", C).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex(), $e = h(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", oe).getRegex(), K = { blockquote: $e, code: be, def: ye, fences: Re, heading: Oe, hr: C, html: Se, lheading: ie, list: Pe, newline: xe, paragraph: oe, table: E, text: we }, re = h("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", C).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex(), _e = { ...K, lheading: Te, table: re, paragraph: h(F).replace("hr", C).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", re).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex() }, Le = { ...K, html: h(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", U).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: E, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: h(F).replace("hr", C).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", ie).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, Me = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, ze = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, ae = /^( {2,}|\\)\n(?!\s*$)/, Ae = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, D = /[\p{P}\p{S}]/u, W = /[\s\p{P}\p{S}]/u, le = /[^\s\p{P}\p{S}]/u, Ee = h(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, W).getRegex(), ue = /(?!~)[\p{P}\p{S}]/u, Ce = /(?!~)[\s\p{P}\p{S}]/u, Ie = /(?:[^\s\p{P}\p{S}]|~)/u, Be = /\[[^\[\]]*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)|`[^`]*?`|<(?! )[^<>]*?>/g, pe = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, qe = h(pe, "u").replace(/punct/g, D).getRegex(), ve = h(pe, "u").replace(/punct/g, ue).getRegex(), ce = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", De = h(ce, "gu").replace(/notPunctSpace/g, le).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), He = h(ce, "gu").replace(/notPunctSpace/g, Ie).replace(/punctSpace/g, Ce).replace(/punct/g, ue).getRegex(), Ze = h("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, le).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), Ge = h(/\\(punct)/, "gu").replace(/punct/g, D).getRegex(), Ne = h(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), je = h(U).replace("(?:-->|$)", "-->").getRegex(), Fe = h("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", je).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), q = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`[^`]*`|[^\[\]\\`])*?/, Qe = h(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", q).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), he = h(/^!?\[(label)\]\[(ref)\]/).replace("label", q).replace("ref", Q).getRegex(), de = h(/^!?\[(ref)\](?:\[\])?/).replace("ref", Q).getRegex(), Ue = h("reflink|nolink(?!\\()", "g").replace("reflink", he).replace("nolink", de).getRegex(), X = { _backpedal: E, anyPunctuation: Ge, autolink: Ne, blockSkip: Be, br: ae, code: ze, del: E, emStrongLDelim: qe, emStrongRDelimAst: De, emStrongRDelimUnd: Ze, escape: Me, link: Qe, nolink: de, punctuation: Ee, reflink: he, reflinkSearch: Ue, tag: Fe, text: Ae, url: E }, Ke = { ...X, link: h(/^!?\[(label)\]\((.*?)\)/).replace("label", q).getRegex(), reflink: h(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", q).getRegex() }, N = { ...X, emStrongRDelimAst: He, emStrongLDelim: ve, url: h(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }, We = { ...N, br: h(ae).replace("{2,}", "*").getRegex(), text: h(N.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, I = { normal: K, gfm: _e, pedantic: Le }, M = { normal: X, gfm: N, breaks: We, pedantic: Ke };
var Xe = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, ke = (l3) => Xe[l3];
function w(l3, e) {
  if (e) {
    if (m.escapeTest.test(l3)) return l3.replace(m.escapeReplace, ke);
  } else if (m.escapeTestNoEncode.test(l3)) return l3.replace(m.escapeReplaceNoEncode, ke);
  return l3;
}
function J(l3) {
  try {
    l3 = encodeURI(l3).replace(m.percentDecode, "%");
  } catch {
    return null;
  }
  return l3;
}
function V(l3, e) {
  let t = l3.replace(m.findPipe, (i, s, o) => {
    let a = false, u = s;
    for (; --u >= 0 && o[u] === "\\"; ) a = !a;
    return a ? "|" : " |";
  }), n = t.split(m.splitPipe), r = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; r < n.length; r++) n[r] = n[r].trim().replace(m.slashPipe, "|");
  return n;
}
function z(l3, e, t) {
  let n = l3.length;
  if (n === 0) return "";
  let r = 0;
  for (; r < n; ) {
    let i = l3.charAt(n - r - 1);
    if (i === e && true) r++;
    else break;
  }
  return l3.slice(0, n - r);
}
function ge(l3, e) {
  if (l3.indexOf(e[1]) === -1) return -1;
  let t = 0;
  for (let n = 0; n < l3.length; n++) if (l3[n] === "\\") n++;
  else if (l3[n] === e[0]) t++;
  else if (l3[n] === e[1] && (t--, t < 0)) return n;
  return t > 0 ? -2 : -1;
}
function fe(l3, e, t, n, r) {
  let i = e.href, s = e.title || null, o = l3[1].replace(r.other.outputLinkReplace, "$1");
  n.state.inLink = true;
  let a = { type: l3[0].charAt(0) === "!" ? "image" : "link", raw: t, href: i, title: s, text: o, tokens: n.inlineTokens(o) };
  return n.state.inLink = false, a;
}
function Je(l3, e, t) {
  let n = l3.match(t.other.indentCodeCompensation);
  if (n === null) return e;
  let r = n[1];
  return e.split(`
`).map((i) => {
    let s = i.match(t.other.beginningSpace);
    if (s === null) return i;
    let [o] = s;
    return o.length >= r.length ? i.slice(r.length) : i;
  }).join(`
`);
}
var y = class {
  options;
  rules;
  lexer;
  constructor(e) {
    this.options = e || O;
  }
  space(e) {
    let t = this.rules.block.newline.exec(e);
    if (t && t[0].length > 0) return { type: "space", raw: t[0] };
  }
  code(e) {
    let t = this.rules.block.code.exec(e);
    if (t) {
      let n = t[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : z(n, `
`) };
    }
  }
  fences(e) {
    let t = this.rules.block.fences.exec(e);
    if (t) {
      let n = t[0], r = Je(n, t[3] || "", this.rules);
      return { type: "code", raw: n, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2], text: r };
    }
  }
  heading(e) {
    let t = this.rules.block.heading.exec(e);
    if (t) {
      let n = t[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let r = z(n, "#");
        (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (n = r.trim());
      }
      return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(e) {
    let t = this.rules.block.hr.exec(e);
    if (t) return { type: "hr", raw: z(t[0], `
`) };
  }
  blockquote(e) {
    let t = this.rules.block.blockquote.exec(e);
    if (t) {
      let n = z(t[0], `
`).split(`
`), r = "", i = "", s = [];
      for (; n.length > 0; ) {
        let o = false, a = [], u;
        for (u = 0; u < n.length; u++) if (this.rules.other.blockquoteStart.test(n[u])) a.push(n[u]), o = true;
        else if (!o) a.push(n[u]);
        else break;
        n = n.slice(u);
        let p = a.join(`
`), c = p.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r = r ? `${r}
${p}` : p, i = i ? `${i}
${c}` : c;
        let f = this.lexer.state.top;
        if (this.lexer.state.top = true, this.lexer.blockTokens(c, s, true), this.lexer.state.top = f, n.length === 0) break;
        let k = s.at(-1);
        if (k?.type === "code") break;
        if (k?.type === "blockquote") {
          let x = k, g = x.raw + `
` + n.join(`
`), T = this.blockquote(g);
          s[s.length - 1] = T, r = r.substring(0, r.length - x.raw.length) + T.raw, i = i.substring(0, i.length - x.text.length) + T.text;
          break;
        } else if (k?.type === "list") {
          let x = k, g = x.raw + `
` + n.join(`
`), T = this.list(g);
          s[s.length - 1] = T, r = r.substring(0, r.length - k.raw.length) + T.raw, i = i.substring(0, i.length - x.raw.length) + T.raw, n = g.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: r, tokens: s, text: i };
    }
  }
  list(e) {
    let t = this.rules.block.list.exec(e);
    if (t) {
      let n = t[1].trim(), r = n.length > 1, i = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: false, items: [] };
      n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), o = false;
      for (; e; ) {
        let u = false, p = "", c = "";
        if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break;
        p = t[0], e = e.substring(p.length);
        let f = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (H) => " ".repeat(3 * H.length)), k = e.split(`
`, 1)[0], x = !f.trim(), g = 0;
        if (this.options.pedantic ? (g = 2, c = f.trimStart()) : x ? g = t[1].length + 1 : (g = t[2].search(this.rules.other.nonSpaceChar), g = g > 4 ? 1 : g, c = f.slice(g), g += t[1].length), x && this.rules.other.blankLine.test(k) && (p += k + `
`, e = e.substring(k.length + 1), u = true), !u) {
          let H = this.rules.other.nextBulletRegex(g), ee = this.rules.other.hrRegex(g), te = this.rules.other.fencesBeginRegex(g), ne = this.rules.other.headingBeginRegex(g), me = this.rules.other.htmlBeginRegex(g);
          for (; e; ) {
            let Z = e.split(`
`, 1)[0], A;
            if (k = Z, this.options.pedantic ? (k = k.replace(this.rules.other.listReplaceNesting, "  "), A = k) : A = k.replace(this.rules.other.tabCharGlobal, "    "), te.test(k) || ne.test(k) || me.test(k) || H.test(k) || ee.test(k)) break;
            if (A.search(this.rules.other.nonSpaceChar) >= g || !k.trim()) c += `
` + A.slice(g);
            else {
              if (x || f.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || te.test(f) || ne.test(f) || ee.test(f)) break;
              c += `
` + k;
            }
            !x && !k.trim() && (x = true), p += Z + `
`, e = e.substring(Z.length + 1), f = A.slice(g);
          }
        }
        i.loose || (o ? i.loose = true : this.rules.other.doubleBlankLine.test(p) && (o = true));
        let T = null, Y;
        this.options.gfm && (T = this.rules.other.listIsTask.exec(c), T && (Y = T[0] !== "[ ] ", c = c.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: p, task: !!T, checked: Y, loose: false, text: c, tokens: [] }), i.raw += p;
      }
      let a = i.items.at(-1);
      if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let u = 0; u < i.items.length; u++) if (this.lexer.state.top = false, i.items[u].tokens = this.lexer.blockTokens(i.items[u].text, []), !i.loose) {
        let p = i.items[u].tokens.filter((f) => f.type === "space"), c = p.length > 0 && p.some((f) => this.rules.other.anyLine.test(f.raw));
        i.loose = c;
      }
      if (i.loose) for (let u = 0; u < i.items.length; u++) i.items[u].loose = true;
      return i;
    }
  }
  html(e) {
    let t = this.rules.block.html.exec(e);
    if (t) return { type: "html", block: true, raw: t[0], pre: t[1] === "pre" || t[1] === "script" || t[1] === "style", text: t[0] };
  }
  def(e) {
    let t = this.rules.block.def.exec(e);
    if (t) {
      let n = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
      return { type: "def", tag: n, raw: t[0], href: r, title: i };
    }
  }
  table(e) {
    let t = this.rules.block.table.exec(e);
    if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;
    let n = V(t[1]), r = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: t[0], header: [], align: [], rows: [] };
    if (n.length === r.length) {
      for (let o of r) this.rules.other.tableAlignRight.test(o) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(o) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(o) ? s.align.push("left") : s.align.push(null);
      for (let o = 0; o < n.length; o++) s.header.push({ text: n[o], tokens: this.lexer.inline(n[o]), header: true, align: s.align[o] });
      for (let o of i) s.rows.push(V(o, s.header.length).map((a, u) => ({ text: a, tokens: this.lexer.inline(a), header: false, align: s.align[u] })));
      return s;
    }
  }
  lheading(e) {
    let t = this.rules.block.lheading.exec(e);
    if (t) return { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) };
  }
  paragraph(e) {
    let t = this.rules.block.paragraph.exec(e);
    if (t) {
      let n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
      return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(e) {
    let t = this.rules.block.text.exec(e);
    if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
  }
  escape(e) {
    let t = this.rules.inline.escape.exec(e);
    if (t) return { type: "escape", raw: t[0], text: t[1] };
  }
  tag(e) {
    let t = this.rules.inline.tag.exec(e);
    if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: t[0] };
  }
  link(e) {
    let t = this.rules.inline.link.exec(e);
    if (t) {
      let n = t[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let s = z(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0) return;
      } else {
        let s = ge(t[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let a = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
          t[2] = t[2].substring(0, s), t[0] = t[0].substring(0, a).trim(), t[3] = "";
        }
      }
      let r = t[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(r);
        s && (r = s[1], i = s[3]);
      } else i = t[3] ? t[3].slice(1, -1) : "";
      return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r = r.slice(1) : r = r.slice(1, -1)), fe(t, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, t[0], this.lexer, this.rules);
    }
  }
  reflink(e, t) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let r = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = t[r.toLowerCase()];
      if (!i) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return fe(n, i, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, t, n = "") {
    let r = this.rules.inline.emStrongLDelim.exec(e);
    if (!r || r[3] && n.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(r[1] || r[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
      let s = [...r[0]].length - 1, o, a, u = s, p = 0, c = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, t = t.slice(-1 * e.length + s); (r = c.exec(t)) != null; ) {
        if (o = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !o) continue;
        if (a = [...o].length, r[3] || r[4]) {
          u += a;
          continue;
        } else if ((r[5] || r[6]) && s % 3 && !((s + a) % 3)) {
          p += a;
          continue;
        }
        if (u -= a, u > 0) continue;
        a = Math.min(a, a + u + p);
        let f = [...r[0]][0].length, k = e.slice(0, s + r.index + f + a);
        if (Math.min(s, a) % 2) {
          let g = k.slice(1, -1);
          return { type: "em", raw: k, text: g, tokens: this.lexer.inlineTokens(g) };
        }
        let x = k.slice(2, -2);
        return { type: "strong", raw: k, text: x, tokens: this.lexer.inlineTokens(x) };
      }
    }
  }
  codespan(e) {
    let t = this.rules.inline.code.exec(e);
    if (t) {
      let n = t[2].replace(this.rules.other.newLineCharGlobal, " "), r = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return r && i && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: t[0], text: n };
    }
  }
  br(e) {
    let t = this.rules.inline.br.exec(e);
    if (t) return { type: "br", raw: t[0] };
  }
  del(e) {
    let t = this.rules.inline.del.exec(e);
    if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) };
  }
  autolink(e) {
    let t = this.rules.inline.autolink.exec(e);
    if (t) {
      let n, r;
      return t[2] === "@" ? (n = t[1], r = "mailto:" + n) : (n = t[1], r = n), { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(e) {
    let t;
    if (t = this.rules.inline.url.exec(e)) {
      let n, r;
      if (t[2] === "@") n = t[0], r = "mailto:" + n;
      else {
        let i;
        do
          i = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
        while (i !== t[0]);
        n = t[0], t[1] === "www." ? r = "http://" + t[0] : r = t[0];
      }
      return { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(e) {
    let t = this.rules.inline.text.exec(e);
    if (t) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: t[0], text: t[0], escaped: n };
    }
  }
};
var b = class l {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || O, this.options.tokenizer = this.options.tokenizer || new y(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
    let t = { other: m, block: I.normal, inline: M.normal };
    this.options.pedantic ? (t.block = I.pedantic, t.inline = M.pedantic) : this.options.gfm && (t.block = I.gfm, this.options.breaks ? t.inline = M.breaks : t.inline = M.gfm), this.tokenizer.rules = t;
  }
  static get rules() {
    return { block: I, inline: M };
  }
  static lex(e, t) {
    return new l(t).lex(e);
  }
  static lexInline(e, t) {
    return new l(t).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(m.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let t = 0; t < this.inlineQueue.length; t++) {
      let n = this.inlineQueue[t];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, t = [], n = false) {
    for (this.options.pedantic && (e = e.replace(m.tabCharGlobal, "    ").replace(m.spaceLine, "")); e; ) {
      let r;
      if (this.options.extensions?.block?.some((s) => (r = s.call({ lexer: this }, e, t)) ? (e = e.substring(r.raw.length), t.push(r), true) : false)) continue;
      if (r = this.tokenizer.space(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        r.raw.length === 1 && s !== void 0 ? s.raw += `
` : t.push(r);
        continue;
      }
      if (r = this.tokenizer.code(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.at(-1).src = s.text) : t.push(r);
        continue;
      }
      if (r = this.tokenizer.fences(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.heading(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.hr(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.blockquote(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.list(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.html(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.def(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = { href: r.href, title: r.title }, t.push(r));
        continue;
      }
      if (r = this.tokenizer.table(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.lheading(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      let i = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, o = e.slice(1), a;
        this.options.extensions.startBlock.forEach((u) => {
          a = u.call({ lexer: this }, o), typeof a == "number" && a >= 0 && (s = Math.min(s, a));
        }), s < 1 / 0 && s >= 0 && (i = e.substring(0, s + 1));
      }
      if (this.state.top && (r = this.tokenizer.paragraph(i))) {
        let s = t.at(-1);
        n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r), n = i.length !== e.length, e = e.substring(r.raw.length);
        continue;
      }
      if (r = this.tokenizer.text(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = true, t;
  }
  inline(e, t = []) {
    return this.inlineQueue.push({ src: e, tokens: t }), t;
  }
  inlineTokens(e, t = []) {
    let n = e, r = null;
    if (this.tokens.links) {
      let o = Object.keys(this.tokens.links);
      if (o.length > 0) for (; (r = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) o.includes(r[0].slice(r[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (r = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, r.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (r = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n;
    let i = false, s = "";
    for (; e; ) {
      i || (s = ""), i = false;
      let o;
      if (this.options.extensions?.inline?.some((u) => (o = u.call({ lexer: this }, e, t)) ? (e = e.substring(o.raw.length), t.push(o), true) : false)) continue;
      if (o = this.tokenizer.escape(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.tag(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.link(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(o.raw.length);
        let u = t.at(-1);
        o.type === "text" && u?.type === "text" ? (u.raw += o.raw, u.text += o.text) : t.push(o);
        continue;
      }
      if (o = this.tokenizer.emStrong(e, n, s)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.codespan(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.br(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.del(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.autolink(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (!this.state.inLink && (o = this.tokenizer.url(e))) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      let a = e;
      if (this.options.extensions?.startInline) {
        let u = 1 / 0, p = e.slice(1), c;
        this.options.extensions.startInline.forEach((f) => {
          c = f.call({ lexer: this }, p), typeof c == "number" && c >= 0 && (u = Math.min(u, c));
        }), u < 1 / 0 && u >= 0 && (a = e.substring(0, u + 1));
      }
      if (o = this.tokenizer.inlineText(a)) {
        e = e.substring(o.raw.length), o.raw.slice(-1) !== "_" && (s = o.raw.slice(-1)), i = true;
        let u = t.at(-1);
        u?.type === "text" ? (u.raw += o.raw, u.text += o.text) : t.push(o);
        continue;
      }
      if (e) {
        let u = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else throw new Error(u);
      }
    }
    return t;
  }
};
var P = class {
  options;
  parser;
  constructor(e) {
    this.options = e || O;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: t, escaped: n }) {
    let r = (t || "").match(m.notSpaceStart)?.[0], i = e.replace(m.endingNewline, "") + `
`;
    return r ? '<pre><code class="language-' + w(r) + '">' + (n ? i : w(i, true)) + `</code></pre>
` : "<pre><code>" + (n ? i : w(i, true)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  def(e) {
    return "";
  }
  heading({ tokens: e, depth: t }) {
    return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    let t = e.ordered, n = e.start, r = "";
    for (let o = 0; o < e.items.length; o++) {
      let a = e.items[o];
      r += this.listitem(a);
    }
    let i = t ? "ol" : "ul", s = t && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + i + s + `>
` + r + "</" + i + `>
`;
  }
  listitem(e) {
    let t = "";
    if (e.task) {
      let n = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + w(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = true)) : e.tokens.unshift({ type: "text", raw: n + " ", text: n + " ", escaped: true }) : t += n + " ";
    }
    return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let t = "", n = "";
    for (let i = 0; i < e.header.length; i++) n += this.tablecell(e.header[i]);
    t += this.tablerow({ text: n });
    let r = "";
    for (let i = 0; i < e.rows.length; i++) {
      let s = e.rows[i];
      n = "";
      for (let o = 0; o < s.length; o++) n += this.tablecell(s[o]);
      r += this.tablerow({ text: n });
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + r + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    let t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t + `</${n}>
`;
  }
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${w(e, true)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: t, tokens: n }) {
    let r = this.parser.parseInline(n), i = J(e);
    if (i === null) return r;
    e = i;
    let s = '<a href="' + e + '"';
    return t && (s += ' title="' + w(t) + '"'), s += ">" + r + "</a>", s;
  }
  image({ href: e, title: t, text: n, tokens: r }) {
    r && (n = this.parser.parseInline(r, this.parser.textRenderer));
    let i = J(e);
    if (i === null) return w(n);
    e = i;
    let s = `<img src="${e}" alt="${n}"`;
    return t && (s += ` title="${w(t)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : w(e.text);
  }
};
var $ = class {
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
};
var R = class l2 {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || O, this.options.renderer = this.options.renderer || new P(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new $();
  }
  static parse(e, t) {
    return new l2(t).parse(e);
  }
  static parseInline(e, t) {
    return new l2(t).parseInline(e);
  }
  parse(e, t = true) {
    let n = "";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (this.options.extensions?.renderers?.[i.type]) {
        let o = i, a = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (a !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(o.type)) {
          n += a || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let o = s, a = this.renderer.text(o);
          for (; r + 1 < e.length && e[r + 1].type === "text"; ) o = e[++r], a += `
` + this.renderer.text(o);
          t ? n += this.renderer.paragraph({ type: "paragraph", raw: a, text: a, tokens: [{ type: "text", raw: a, text: a, escaped: true }] }) : n += a;
          continue;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
  parseInline(e, t = this.renderer) {
    let n = "";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (this.options.extensions?.renderers?.[i.type]) {
        let o = this.options.extensions.renderers[i.type].call({ parser: this }, i);
        if (o !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) {
          n += o || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "escape": {
          n += t.text(s);
          break;
        }
        case "html": {
          n += t.html(s);
          break;
        }
        case "link": {
          n += t.link(s);
          break;
        }
        case "image": {
          n += t.image(s);
          break;
        }
        case "strong": {
          n += t.strong(s);
          break;
        }
        case "em": {
          n += t.em(s);
          break;
        }
        case "codespan": {
          n += t.codespan(s);
          break;
        }
        case "br": {
          n += t.br(s);
          break;
        }
        case "del": {
          n += t.del(s);
          break;
        }
        case "text": {
          n += t.text(s);
          break;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
};
var S = class {
  options;
  block;
  constructor(e) {
    this.options = e || O;
  }
  static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
  static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
  preprocess(e) {
    return e;
  }
  postprocess(e) {
    return e;
  }
  processAllTokens(e) {
    return e;
  }
  emStrongMask(e) {
    return e;
  }
  provideLexer() {
    return this.block ? b.lex : b.lexInline;
  }
  provideParser() {
    return this.block ? R.parse : R.parseInline;
  }
};
var B = class {
  defaults = L();
  options = this.setOptions;
  parse = this.parseMarkdown(true);
  parseInline = this.parseMarkdown(false);
  Parser = R;
  Renderer = P;
  TextRenderer = $;
  Lexer = b;
  Tokenizer = y;
  Hooks = S;
  constructor(...e) {
    this.use(...e);
  }
  walkTokens(e, t) {
    let n = [];
    for (let r of e) switch (n = n.concat(t.call(this, r)), r.type) {
      case "table": {
        let i = r;
        for (let s of i.header) n = n.concat(this.walkTokens(s.tokens, t));
        for (let s of i.rows) for (let o of s) n = n.concat(this.walkTokens(o.tokens, t));
        break;
      }
      case "list": {
        let i = r;
        n = n.concat(this.walkTokens(i.items, t));
        break;
      }
      default: {
        let i = r;
        this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
          let o = i[s].flat(1 / 0);
          n = n.concat(this.walkTokens(o, t));
        }) : i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)));
      }
    }
    return n;
  }
  use(...e) {
    let t = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      let r = { ...n };
      if (r.async = this.defaults.async || r.async || false, n.extensions && (n.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let s = t.renderers[i.name];
          s ? t.renderers[i.name] = function(...o) {
            let a = i.renderer.apply(this, o);
            return a === false && (a = s.apply(this, o)), a;
          } : t.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = t[i.level];
          s ? s.unshift(i.tokenizer) : t[i.level] = [i.tokenizer], i.start && (i.level === "block" ? t.startBlock ? t.startBlock.push(i.start) : t.startBlock = [i.start] : i.level === "inline" && (t.startInline ? t.startInline.push(i.start) : t.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens);
      }), r.extensions = t), n.renderer) {
        let i = this.defaults.renderer || new P(this.defaults);
        for (let s in n.renderer) {
          if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let o = s, a = n.renderer[o], u = i[o];
          i[o] = (...p) => {
            let c = a.apply(i, p);
            return c === false && (c = u.apply(i, p)), c || "";
          };
        }
        r.renderer = i;
      }
      if (n.tokenizer) {
        let i = this.defaults.tokenizer || new y(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let o = s, a = n.tokenizer[o], u = i[o];
          i[o] = (...p) => {
            let c = a.apply(i, p);
            return c === false && (c = u.apply(i, p)), c;
          };
        }
        r.tokenizer = i;
      }
      if (n.hooks) {
        let i = this.defaults.hooks || new S();
        for (let s in n.hooks) {
          if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let o = s, a = n.hooks[o], u = i[o];
          S.passThroughHooks.has(s) ? i[o] = (p) => {
            if (this.defaults.async && S.passThroughHooksRespectAsync.has(s)) return Promise.resolve(a.call(i, p)).then((f) => u.call(i, f));
            let c = a.call(i, p);
            return u.call(i, c);
          } : i[o] = (...p) => {
            let c = a.apply(i, p);
            return c === false && (c = u.apply(i, p)), c;
          };
        }
        r.hooks = i;
      }
      if (n.walkTokens) {
        let i = this.defaults.walkTokens, s = n.walkTokens;
        r.walkTokens = function(o) {
          let a = [];
          return a.push(s.call(this, o)), i && (a = a.concat(i.call(this, o))), a;
        };
      }
      this.defaults = { ...this.defaults, ...r };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, t) {
    return b.lex(e, t ?? this.defaults);
  }
  parser(e, t) {
    return R.parse(e, t ?? this.defaults);
  }
  parseMarkdown(e) {
    return (n, r) => {
      let i = { ...r }, s = { ...this.defaults, ...i }, o = this.onError(!!s.silent, !!s.async);
      if (this.defaults.async === true && i.async === false) return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof n > "u" || n === null) return o(new Error("marked(): input parameter is undefined or null"));
      if (typeof n != "string") return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
      s.hooks && (s.hooks.options = s, s.hooks.block = e);
      let a = s.hooks ? s.hooks.provideLexer() : e ? b.lex : b.lexInline, u = s.hooks ? s.hooks.provideParser() : e ? R.parse : R.parseInline;
      if (s.async) return Promise.resolve(s.hooks ? s.hooks.preprocess(n) : n).then((p) => a(p, s)).then((p) => s.hooks ? s.hooks.processAllTokens(p) : p).then((p) => s.walkTokens ? Promise.all(this.walkTokens(p, s.walkTokens)).then(() => p) : p).then((p) => u(p, s)).then((p) => s.hooks ? s.hooks.postprocess(p) : p).catch(o);
      try {
        s.hooks && (n = s.hooks.preprocess(n));
        let p = a(n, s);
        s.hooks && (p = s.hooks.processAllTokens(p)), s.walkTokens && this.walkTokens(p, s.walkTokens);
        let c = u(p, s);
        return s.hooks && (c = s.hooks.postprocess(c)), c;
      } catch (p) {
        return o(p);
      }
    };
  }
  onError(e, t) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        let r = "<p>An error occurred:</p><pre>" + w(n.message + "", true) + "</pre>";
        return t ? Promise.resolve(r) : r;
      }
      if (t) return Promise.reject(n);
      throw n;
    };
  }
};
var _ = new B();
function d(l3, e) {
  return _.parse(l3, e);
}
d.options = d.setOptions = function(l3) {
  return _.setOptions(l3), d.defaults = _.defaults, G(d.defaults), d;
};
d.getDefaults = L;
d.defaults = O;
d.use = function(...l3) {
  return _.use(...l3), d.defaults = _.defaults, G(d.defaults), d;
};
d.walkTokens = function(l3, e) {
  return _.walkTokens(l3, e);
};
d.parseInline = _.parseInline;
d.Parser = R;
d.parser = R.parse;
d.Renderer = P;
d.TextRenderer = $;
d.Lexer = b;
d.lexer = b.lex;
d.Tokenizer = y;
d.Hooks = S;
d.parse = d;
d.options;
d.setOptions;
d.use;
d.walkTokens;
d.parseInline;
R.parse;
b.lex;
class MarkdownParser {
  constructor() {
    d.setOptions({
      breaks: true,
      // Convert line breaks to <br>
      gfm: true
      // GitHub Flavored Markdown
    });
  }
  /**
   * Parse markdown content to HTML
   * @param content - Markdown content string
   * @returns HTML string
   */
  parse(content) {
    if (!content || content.trim() === "") {
      return "";
    }
    try {
      return d.parse(content);
    } catch (error) {
      console.error("Error parsing markdown:", error);
      return `<p>Error parsing markdown content</p>`;
    }
  }
}
class ContentService {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.markdownParser = new MarkdownParser();
  }
  /**
   * Load content from various sources (file, URL, etc.)
   * @param sourcePath - Path or URL to the content
   * @returns Promise<string> - The loaded content
   */
  async loadContentFromSource(sourcePath) {
    try {
      if (this.cache.has(sourcePath)) {
        return this.cache.get(sourcePath);
      }
      const response = await fetch(sourcePath);
      if (!response.ok) {
        throw new ContentLoadError(
          `Failed to load content from ${sourcePath}: ${response.status} ${response.statusText}`,
          sourcePath,
          response.status
        );
      }
      const content = await response.text();
      this.validateContent(content);
      this.cache.set(sourcePath, content);
      return content;
    } catch (error) {
      if (error instanceof ContentLoadError) {
        throw error;
      }
      throw new ContentLoadError(
        `Error loading content from ${sourcePath}: ${error instanceof Error ? error.message : "Unknown error"}`,
        sourcePath
      );
    }
  }
  /**
   * Parse content into slides
   * @param content - Raw content string
   * @returns Array of parsed slides
   */
  parseContent(content) {
    try {
      this.validateContent(content);
      return this.parseMarkdown(content);
    } catch (error) {
      throw new ContentParseError(
        `Failed to parse content: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Parse markdown content to HTML
   * @param content - Markdown content
   * @returns HTML string
   */
  parseMarkdownToHtml(content) {
    try {
      return this.markdownParser.parse(content);
    } catch (error) {
      throw new ContentParseError(
        `Failed to parse markdown: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Clear content cache
   */
  clearCache() {
    this.cache.clear();
  }
  /**
   * Get cache statistics
   */
  getCacheStats() {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys())
    };
  }
  /**
   * Parse markdown content into slides
   * @param content - Raw markdown content
   * @returns Array of slides
   */
  parseMarkdown(content) {
    const slideContents = content.split(/^---\s*$/gm).filter((slide) => slide.trim());
    if (slideContents.length === 0) {
      throw new ContentParseError("No slides found in content");
    }
    return slideContents.map((slideContent, index) => {
      const trimmedContent = slideContent.trim();
      return {
        id: `slide-${index}`,
        content: trimmedContent,
        html: this.markdownParser.parse(trimmedContent)
      };
    });
  }
  /**
   * Validate content before processing
   * @param content - Content to validate
   */
  validateContent(content) {
    if (!content || typeof content !== "string") {
      throw new ContentValidationError("Content must be a non-empty string");
    }
    if (content.trim().length === 0) {
      throw new ContentValidationError("Content cannot be empty");
    }
    if (content.length < 10) {
      throw new ContentValidationError(
        "Content is too short to be a valid presentation"
      );
    }
  }
}
class ContentError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = this.constructor.name;
  }
}
class ContentLoadError extends ContentError {
  constructor(message, sourcePath, statusCode) {
    super(message, "CONTENT_LOAD_ERROR");
    this.sourcePath = sourcePath;
    this.statusCode = statusCode;
  }
}
class ContentParseError extends ContentError {
  constructor(message) {
    super(message, "CONTENT_PARSE_ERROR");
  }
}
class ContentValidationError extends ContentError {
  constructor(message) {
    super(message, "CONTENT_VALIDATION_ERROR");
  }
}
class NavigationService {
  constructor(container, keyboardEnabled = false, touchEnabled = false, navigationCallback) {
    this.slides = [];
    this.currentSlideIndex = 0;
    this.keyboardEnabled = false;
    this.touchEnabled = false;
    this.eventListeners = /* @__PURE__ */ new Map();
    this.container = container;
    this.keyboardEnabled = keyboardEnabled;
    this.touchEnabled = touchEnabled;
    this.navigationCallback = navigationCallback;
  }
  /**
   * Set slides for navigation
   */
  setSlides(slides) {
    this.slides = slides;
    this.currentSlideIndex = Math.min(
      this.currentSlideIndex,
      slides.length - 1
    );
  }
  /**
   * Set current slide index
   */
  setCurrentSlideIndex(index) {
    if (index >= 0 && index < this.slides.length) {
      this.currentSlideIndex = index;
    }
  }
  /**
   * Get current slide index
   */
  getCurrentSlideIndex() {
    return this.currentSlideIndex;
  }
  /**
   * Get total number of slides
   */
  getTotalSlides() {
    return this.slides.length;
  }
  /**
   * Setup navigation controls
   */
  setupNavigation() {
    this.setupKeyboardNavigation();
    this.setupTouchNavigation();
  }
  /**
   * Setup keyboard navigation
   */
  setupKeyboardNavigation() {
    if (!this.keyboardEnabled) return;
    const handleKeyDown = (event) => {
      this.handleKeyboardEvent(event);
    };
    document.addEventListener("keydown", handleKeyDown);
    this.eventListeners.set("keydown", handleKeyDown);
  }
  /**
   * Setup touch navigation
   */
  setupTouchNavigation() {
    if (!this.touchEnabled) return;
    let startX = 0;
    let startY = 0;
    let endX = 0;
    let endY = 0;
    const handleTouchStart = (event) => {
      const touch = event.touches[0];
      startX = touch.clientX;
      startY = touch.clientY;
    };
    const handleTouchEnd = (event) => {
      const touch = event.changedTouches[0];
      endX = touch.clientX;
      endY = touch.clientY;
      this.handleTouchGesture(startX, startY, endX, endY);
    };
    this.container.addEventListener("touchstart", handleTouchStart);
    this.container.addEventListener("touchend", handleTouchEnd);
    this.eventListeners.set("touchstart", handleTouchStart);
    this.eventListeners.set("touchend", handleTouchEnd);
  }
  /**
   * Handle keyboard events
   */
  handleKeyboardEvent(event) {
    const key = event.key;
    switch (key) {
      case "ArrowRight":
      case "ArrowDown":
      case " ":
        event.preventDefault();
        this.nextSlide();
        break;
      case "ArrowLeft":
      case "ArrowUp":
        event.preventDefault();
        this.previousSlide();
        break;
      case "Home":
        event.preventDefault();
        this.goToFirstSlide();
        break;
      case "End":
        event.preventDefault();
        this.goToLastSlide();
        break;
    }
  }
  /**
   * Handle touch gestures
   */
  handleTouchGesture(startX, startY, endX, endY) {
    const deltaX = endX - startX;
    const deltaY = endY - startY;
    const minSwipeDistance = 50;
    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
      if (deltaX > 0) {
        this.previousSlide();
      } else {
        this.nextSlide();
      }
    } else if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > minSwipeDistance) {
      if (deltaY > 0) {
        this.previousSlide();
      } else {
        this.nextSlide();
      }
    }
  }
  /**
   * Navigate to next slide
   */
  nextSlide() {
    if (this.currentSlideIndex < this.slides.length - 1) {
      this.goToSlide(this.currentSlideIndex + 1);
    }
  }
  /**
   * Navigate to previous slide
   */
  previousSlide() {
    if (this.currentSlideIndex > 0) {
      this.goToSlide(this.currentSlideIndex - 1);
    }
  }
  /**
   * Go to first slide
   */
  goToFirstSlide() {
    this.goToSlide(0);
  }
  /**
   * Go to last slide
   */
  goToLastSlide() {
    this.goToSlide(this.slides.length - 1);
  }
  /**
   * Go to specific slide
   */
  goToSlide(index) {
    if (index >= 0 && index < this.slides.length && index !== this.currentSlideIndex) {
      this.currentSlideIndex = index;
      this.navigationCallback?.(index);
    }
  }
  /**
   * Check if navigation is at first slide
   */
  isFirstSlide() {
    return this.currentSlideIndex === 0;
  }
  /**
   * Check if navigation is at last slide
   */
  isLastSlide() {
    return this.currentSlideIndex === this.slides.length - 1;
  }
  /**
   * Get navigation statistics
   */
  getNavigationStats() {
    return {
      currentSlide: this.currentSlideIndex,
      totalSlides: this.slides.length,
      progress: this.slides.length > 0 ? (this.currentSlideIndex + 1) / this.slides.length : 0,
      isFirst: this.isFirstSlide(),
      isLast: this.isLastSlide()
    };
  }
  /**
   * Enable keyboard navigation
   */
  enableKeyboard() {
    this.keyboardEnabled = true;
    this.setupKeyboardNavigation();
  }
  /**
   * Disable keyboard navigation
   */
  disableKeyboard() {
    this.keyboardEnabled = false;
    this.removeEventListener("keydown");
  }
  /**
   * Enable touch navigation
   */
  enableTouch() {
    this.touchEnabled = true;
    this.setupTouchNavigation();
  }
  /**
   * Disable touch navigation
   */
  disableTouch() {
    this.touchEnabled = false;
    this.removeEventListener("touchstart");
    this.removeEventListener("touchend");
  }
  /**
   * Remove specific event listener
   */
  removeEventListener(eventType) {
    const listener = this.eventListeners.get(eventType);
    if (listener) {
      if (eventType === "keydown") {
        document.removeEventListener(eventType, listener);
      } else {
        this.container.removeEventListener(eventType, listener);
      }
      this.eventListeners.delete(eventType);
    }
  }
  /**
   * Cleanup all event listeners
   */
  destroy() {
    this.eventListeners.forEach((listener, eventType) => {
      if (eventType === "keydown") {
        document.removeEventListener(eventType, listener);
      } else {
        this.container.removeEventListener(eventType, listener);
      }
    });
    this.eventListeners.clear();
  }
}
class TransitionManager {
  constructor(container, transitionConfig) {
    this.container = container;
    this.transitionConfig = transitionConfig;
  }
  animateTransition(fromIndex, toIndex) {
    const slides = this.container.querySelectorAll(".mostage-slide");
    const fromSlide = slides[fromIndex];
    const toSlide = slides[toIndex];
    if (!fromSlide || !toSlide) return;
    if (fromIndex === toIndex) {
      this.showSlide(toIndex);
      return;
    }
    const duration = this.transitionConfig.duration || 300;
    fromSlide.style.transition = "";
    toSlide.style.transition = "";
    switch (this.transitionConfig.type) {
      case "fade":
        this.fadeTransition(fromSlide, toSlide, duration);
        break;
      case "vertical":
        this.verticalTransition(
          fromSlide,
          toSlide,
          toIndex > fromIndex,
          duration
        );
        break;
      case "slide":
        this.slideTransition(fromSlide, toSlide, toIndex > fromIndex, duration);
        break;
      case "horizontal":
      default:
        this.horizontalTransition(
          fromSlide,
          toSlide,
          toIndex > fromIndex,
          duration
        );
        break;
    }
  }
  showSlide(index) {
    const slides = this.container.querySelectorAll(".mostage-slide");
    slides.forEach((slide, i) => {
      const slideElement = slide;
      slideElement.style.display = i === index ? "block" : "none";
      slideElement.style.opacity = "1";
      slideElement.style.transform = "";
    });
  }
  fadeTransition(fromSlide, toSlide, duration) {
    fromSlide.style.opacity = "0";
    toSlide.style.display = "block";
    toSlide.style.opacity = "0";
    setTimeout(() => {
      toSlide.style.opacity = "1";
      setTimeout(() => {
        fromSlide.style.display = "none";
        fromSlide.style.opacity = "1";
      }, duration);
    }, 50);
  }
  horizontalTransition(fromSlide, toSlide, isNext, duration) {
    const direction = isNext ? "translateX(-100%)" : "translateX(100%)";
    const enterDirection = isNext ? "translateX(100%)" : "translateX(-100%)";
    fromSlide.style.transition = "";
    toSlide.style.transition = "";
    toSlide.style.display = "block";
    toSlide.style.transform = enterDirection;
    toSlide.offsetHeight;
    fromSlide.style.transition = `transform ${duration}ms ${this.transitionConfig.easing || "ease-in-out"}`;
    toSlide.style.transition = `transform ${duration}ms ${this.transitionConfig.easing || "ease-in-out"}`;
    setTimeout(() => {
      fromSlide.style.transform = direction;
      toSlide.style.transform = "translateX(0)";
      setTimeout(() => {
        fromSlide.style.display = "none";
        fromSlide.style.transform = "";
        toSlide.style.transform = "";
        fromSlide.style.transition = "";
        toSlide.style.transition = "";
      }, duration);
    }, 50);
  }
  verticalTransition(fromSlide, toSlide, isNext, duration) {
    const direction = isNext ? "translateY(-100%)" : "translateY(100%)";
    const enterDirection = isNext ? "translateY(100%)" : "translateY(-100%)";
    toSlide.style.display = "block";
    toSlide.style.transform = enterDirection;
    setTimeout(() => {
      fromSlide.style.transform = direction;
      toSlide.style.transform = "translateY(0)";
      setTimeout(() => {
        fromSlide.style.display = "none";
        fromSlide.style.transform = "";
        toSlide.style.transform = "";
      }, duration);
    }, 50);
  }
  slideTransition(fromSlide, toSlide, isNext, duration) {
    this.horizontalTransition(fromSlide, toSlide, isNext, duration);
  }
}
const HELP_DATA = {
  overview: [
    {
      title: "Keyboard Shortcuts",
      items: [
        { description: "Navigate", keys: ["←", "→", "Enter"] },
        { description: "First slide", keys: ["Home"] },
        { description: "Last slide", keys: ["End"] },
        { description: "Exit", keys: ["Esc", "O"] }
      ]
    }
  ],
  normal: [
    {
      title: "Navigation",
      items: [
        { description: "Next slide", keys: ["→", "Space"] },
        { description: "Previous slide", keys: ["←"] },
        { description: "First slide", keys: ["Home"] },
        { description: "Last slide", keys: ["End"] }
      ]
    },
    {
      title: "Modes",
      items: [
        { description: "Overview mode", keys: ["O", "Esc"] },
        { description: "Help", keys: ["H", "?"] }
      ]
    }
  ]
};
class HelpComponent {
  constructor(mode) {
    this.mode = mode;
    this.prefix = mode === "overview" ? "mostage-overview-help" : "mostage-help";
    this.sections = JSON.parse(JSON.stringify(HELP_DATA[mode]));
  }
  createHelpElement() {
    const container = document.createElement("div");
    container.className = this.prefix;
    container.innerHTML = this.generateHTML();
    return container;
  }
  generateHTML() {
    if (this.mode === "overview") {
      const section = this.sections[0];
      return `
        <div class="${this.prefix}-content">
          <div class="${this.prefix}-header">
            <h3>${section.title}</h3>
            <button class="${this.prefix}-close">×</button>
          </div>
          <div class="${this.prefix}-body">
            ${this.renderItems(section.items)}
          </div>
        </div>
      `;
    } else {
      return `
        <div class="${this.prefix}-content">
          <div class="${this.prefix}-header">
            <h3>Keyboard Shortcuts</h3>
            <button class="${this.prefix}-close">×</button>
          </div>
          <div class="${this.prefix}-body">
            ${this.sections.map((section) => this.renderSection(section)).join("")}
          </div>
        </div>
      `;
    }
  }
  renderSection(section) {
    return `
      <div class="${this.prefix}-section">
        <h4>${section.title}</h4>
        ${this.renderItems(section.items)}
      </div>
    `;
  }
  renderItems(items) {
    return items.map((item) => this.renderItem(item)).join("");
  }
  renderItem(item) {
    return `
      <div class="${this.prefix}-item">
        <span class="${this.prefix}-description">${item.description}</span>
        ${this.renderKeys(item.keys)}
      </div>
    `;
  }
  renderKeys(keys) {
    if (keys.length === 1) {
      return `<span class="${this.prefix}-key">${keys[0]}</span>`;
    }
    return `
      <div class="${this.prefix}-keys">
        ${keys.map((key) => `<span class="${this.prefix}-key">${key}</span>`).join("")}
      </div>
    `;
  }
  addCloseButtonListener(element, onClose) {
    const closeButton = element.querySelector(`.${this.prefix}-close`);
    closeButton?.addEventListener("click", onClose);
  }
}
class HelpManager {
  constructor() {
    this.isHelpVisible = false;
    this.helpContainer = null;
    this.wasHelpVisibleBeforeOverview = false;
    this.autoHideTimeout = null;
    this.helpComponent = new HelpComponent("normal");
  }
  toggleHelp() {
    if (this.isHelpVisible) {
      this.hideHelp();
    } else {
      this.showHelp();
    }
  }
  // Show help on initial load with auto-hide after 3 seconds
  showInitialHelp() {
    this.showHelp();
    this.scheduleAutoHide();
  }
  // Schedule auto-hide after 5 seconds
  scheduleAutoHide() {
    this.clearAutoHide();
    this.autoHideTimeout = window.setTimeout(() => {
      this.hideHelp();
    }, 3e3);
  }
  // Clear auto-hide timeout
  clearAutoHide() {
    if (this.autoHideTimeout) {
      clearTimeout(this.autoHideTimeout);
      this.autoHideTimeout = null;
    }
  }
  getHelpVisible() {
    return this.isHelpVisible;
  }
  hideForOverview() {
    if (this.isHelpVisible) {
      this.wasHelpVisibleBeforeOverview = true;
      this.hideHelp();
    } else {
      this.wasHelpVisibleBeforeOverview = false;
    }
  }
  restoreAfterOverview() {
    if (this.wasHelpVisibleBeforeOverview) {
      this.showHelp();
      this.wasHelpVisibleBeforeOverview = false;
    }
  }
  showHelp() {
    if (this.isHelpVisible) return;
    this.isHelpVisible = true;
    this.helpContainer = this.createHelpComponent();
    document.body.appendChild(this.helpContainer);
    requestAnimationFrame(() => {
      if (this.helpContainer) {
        this.helpContainer.classList.add("fade-in");
      }
    });
  }
  hideHelp() {
    if (!this.isHelpVisible) return;
    this.isHelpVisible = false;
    this.clearAutoHide();
    this.hideHelpWithAnimation();
  }
  // Hide help with fade-out animation
  hideHelpWithAnimation() {
    if (!this.helpContainer) return;
    this.helpContainer.classList.add("fade-out");
    this.helpContainer.classList.remove("fade-in");
    setTimeout(() => {
      if (this.helpContainer) {
        this.helpContainer.remove();
        this.helpContainer = null;
      }
    }, 300);
  }
  createHelpComponent() {
    const helpContainer = this.helpComponent.createHelpElement();
    this.helpComponent.addCloseButtonListener(helpContainer, () => {
      this.hideHelp();
    });
    return helpContainer;
  }
}
const version = "1.5.9";
const pkg = {
  version
};
class OverviewManager {
  constructor(container, onSlideChange, onExitOverview, onEnterOverview) {
    this.currentSlideIndex = 0;
    this.isOverviewMode = false;
    this.overviewContainer = null;
    this.overviewSelectedIndex = 0;
    this.container = container;
    this.onSlideChange = onSlideChange;
    this.onExitOverview = onExitOverview;
    this.onEnterOverview = onEnterOverview || (() => {
    });
    this.helpComponent = new HelpComponent("overview");
  }
  setCurrentSlideIndex(index) {
    this.currentSlideIndex = index;
  }
  toggleOverview() {
    if (this.isOverviewMode) {
      this.exitOverview();
    } else {
      this.enterOverview();
    }
  }
  isInOverviewMode() {
    return this.isOverviewMode;
  }
  /**
   * Handles keyboard events in overview mode
   * Supports navigation (arrows, home, end) and actions (enter, escape, o)
   */
  handleOverviewKeyboard(event) {
    if (!this.isOverviewMode) return;
    const key = event.key;
    const keyLower = key.toLowerCase();
    if (key === "ArrowRight") {
      event.preventDefault();
      event.stopPropagation();
      this.nextOverviewSlide();
      return;
    }
    if (key === "ArrowLeft") {
      event.preventDefault();
      event.stopPropagation();
      this.previousOverviewSlide();
      return;
    }
    if (key === "Home") {
      event.preventDefault();
      event.stopPropagation();
      this.goToFirstSlide();
      return;
    }
    if (key === "End") {
      event.preventDefault();
      event.stopPropagation();
      this.goToLastSlide();
      return;
    }
    if (key === "Enter") {
      event.preventDefault();
      event.stopPropagation();
      this.selectOverviewSlide();
      return;
    }
    if (key === "Escape" || keyLower === "o") {
      event.preventDefault();
      event.stopPropagation();
      this.exitOverview();
      return;
    }
  }
  getThumbnails() {
    return this.overviewContainer?.querySelectorAll(".mostage-overview-slide") || null;
  }
  goToFirstSlide() {
    this.overviewSelectedIndex = 0;
    this.updateOverviewSelection();
  }
  goToLastSlide() {
    const thumbnails = this.getThumbnails();
    const actualSlidesCount = thumbnails?.length || 0;
    this.overviewSelectedIndex = actualSlidesCount - 1;
    this.updateOverviewSelection();
  }
  enterOverview() {
    if (this.isOverviewMode) return;
    this.isOverviewMode = true;
    this.overviewSelectedIndex = this.currentSlideIndex;
    this.onEnterOverview();
    this.createOverviewGrid();
  }
  exitOverview() {
    if (!this.isOverviewMode) return;
    this.isOverviewMode = false;
    this.removeOverviewContainer();
    this.onExitOverview();
  }
  removeOverviewContainer() {
    if (this.overviewContainer) {
      this.overviewContainer.remove();
      this.overviewContainer = null;
    }
    const footer = document.querySelector(".mostage-overview-footer");
    if (footer) {
      footer.remove();
    }
    const closeButton = document.querySelector(".mostage-overview-close");
    if (closeButton) {
      closeButton.remove();
    }
  }
  nextOverviewSlide() {
    const thumbnails = this.getThumbnails();
    const actualSlidesCount = thumbnails?.length || 0;
    if (this.overviewSelectedIndex < actualSlidesCount - 1) {
      this.overviewSelectedIndex++;
      this.updateOverviewSelection();
    }
  }
  previousOverviewSlide() {
    if (this.overviewSelectedIndex > 0) {
      this.overviewSelectedIndex--;
      this.updateOverviewSelection();
    }
  }
  selectOverviewSlide() {
    this.onSlideChange(this.overviewSelectedIndex);
    this.exitOverview();
  }
  updateOverviewSelection() {
    const thumbnails = this.getThumbnails();
    if (!thumbnails) return;
    if (this.overviewSelectedIndex >= thumbnails.length) return;
    thumbnails.forEach((thumbnail, index) => {
      const slideElement = thumbnail;
      if (index === this.overviewSelectedIndex) {
        slideElement.classList.add("selected");
        slideElement.scrollIntoView({ behavior: "smooth", block: "center" });
      } else {
        slideElement.classList.remove("selected");
      }
    });
  }
  createOverviewGrid() {
    this.overviewContainer = document.createElement("div");
    this.overviewContainer.className = "mostage-overview";
    const slideElements = this.container.querySelectorAll(
      ".mostage-slide"
    );
    const currentSlideIndex = this.currentSlideIndex;
    slideElements.forEach((slideElement, index) => {
      const thumbnail = this.createThumbnail(
        slideElement,
        index,
        currentSlideIndex
      );
      this.overviewContainer.appendChild(thumbnail);
    });
    const helpComponent = this.createHelpComponent();
    this.helpComponent.addCloseButtonListener(helpComponent, () => {
      this.hideOverviewHelp(helpComponent);
    });
    this.overviewContainer.appendChild(helpComponent);
    requestAnimationFrame(() => {
      helpComponent.classList.add("fade-in");
    });
    document.body.appendChild(this.overviewContainer);
    document.body.appendChild(this.createCloseButton());
    document.body.appendChild(this.createFooter());
    this.updateOverviewSelection();
  }
  createThumbnail(slideElement, index, currentIndex) {
    const thumbnail = document.createElement("div");
    thumbnail.className = "mostage-overview-slide";
    if (index === currentIndex) {
      thumbnail.classList.add("active");
    }
    const computedStyle = window.getComputedStyle(slideElement);
    const backgroundColor = computedStyle.backgroundColor;
    if (backgroundColor && backgroundColor !== "rgba(0, 0, 0, 0)" && backgroundColor !== "transparent") {
      thumbnail.style.backgroundColor = backgroundColor;
    }
    const slideNumber = document.createElement("div");
    slideNumber.className = "mostage-overview-slide-number";
    slideNumber.textContent = (index + 1).toString();
    const contentWrapper = document.createElement("div");
    contentWrapper.className = "mostage-overview-slide-content";
    const slideContentWrapper = slideElement.querySelector(
      ".mostage-slide-content"
    );
    const content = slideContentWrapper ? slideContentWrapper.innerHTML : slideElement.innerHTML;
    contentWrapper.innerHTML = content;
    this.applyThemeToOverviewContent(contentWrapper, slideElement);
    thumbnail.appendChild(slideNumber);
    thumbnail.appendChild(contentWrapper);
    thumbnail.addEventListener("click", () => {
      this.overviewSelectedIndex = index;
      this.updateOverviewSelection();
      this.selectOverviewSlide();
    });
    return thumbnail;
  }
  /**
   * Apply theme styles to overview content to ensure it matches the main slides
   */
  applyThemeToOverviewContent(contentWrapper, originalSlide) {
    const originalStyles = window.getComputedStyle(originalSlide);
    contentWrapper.style.backgroundColor = originalStyles.backgroundColor;
    contentWrapper.style.color = originalStyles.color;
    const allElements = contentWrapper.querySelectorAll("*");
    allElements.forEach((element) => {
      const htmlElement = element;
      const tagName = element.tagName.toLowerCase();
      const originalElement = originalSlide.querySelector(tagName);
      if (originalElement) {
        const originalElementStyles = window.getComputedStyle(originalElement);
        htmlElement.style.color = originalElementStyles.color;
        htmlElement.style.backgroundColor = originalElementStyles.backgroundColor;
        htmlElement.style.borderColor = originalElementStyles.borderColor;
        if (["h1", "h2", "h3", "h4", "h5", "h6"].includes(tagName)) {
          htmlElement.style.background = originalElementStyles.background;
          htmlElement.style.webkitBackgroundClip = originalElementStyles.webkitBackgroundClip;
          htmlElement.style.webkitTextFillColor = originalElementStyles.webkitTextFillColor;
          htmlElement.style.backgroundClip = originalElementStyles.backgroundClip;
          htmlElement.style.textShadow = originalElementStyles.textShadow;
        }
        if (["code", "pre"].includes(tagName)) {
          htmlElement.style.background = originalElementStyles.background;
          htmlElement.style.border = originalElementStyles.border;
        }
        if (tagName === "a") {
          htmlElement.style.color = originalElementStyles.color;
        }
        if (tagName === "blockquote") {
          htmlElement.style.color = originalElementStyles.color;
          htmlElement.style.backgroundColor = originalElementStyles.backgroundColor;
          htmlElement.style.borderLeftColor = originalElementStyles.borderLeftColor;
        }
      }
    });
  }
  createCloseButton() {
    const closeButton = document.createElement("button");
    closeButton.className = "mostage-overview-close";
    closeButton.innerHTML = "×";
    closeButton.addEventListener("click", () => {
      this.exitOverview();
    });
    return closeButton;
  }
  createHelpComponent() {
    return this.helpComponent.createHelpElement();
  }
  createFooter() {
    const footer = document.createElement("div");
    footer.className = "mostage-overview-footer";
    footer.innerHTML = `Made with <a href="https://github.com/mirmousaviii/mostage" target="_blank" rel="noopener noreferrer">Mostage</a> v${pkg.version}`;
    return footer;
  }
  // Hide overview help with fade-out animation
  hideOverviewHelp(helpComponent) {
    helpComponent.classList.add("fade-out");
    helpComponent.classList.remove("fade-in");
    setTimeout(() => {
      helpComponent.style.display = "none";
    }, 300);
  }
}
class CenterContentManager {
  constructor(container) {
    this.container = container;
    this.centerContentConfig = null;
  }
  initialize(config) {
    if (!config) return;
    this.centerContentConfig = {
      vertical: true,
      horizontal: true,
      ...config
    };
    if (!this.centerContentConfig.vertical && !this.centerContentConfig.horizontal) {
      this.centerContentConfig = null;
      return;
    }
    this.setupCenterContentObserver();
    setTimeout(() => this.updateCurrentSlideCentering(), 100);
  }
  onSlideChange() {
    setTimeout(() => this.updateCurrentSlideCentering(), 50);
  }
  setupCenterContentObserver() {
    const observer = new MutationObserver(() => {
      this.updateCurrentSlideCentering();
    });
    if (this.container) {
      observer.observe(this.container, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ["style"]
      });
    }
  }
  updateCurrentSlideCentering() {
    if (!this.centerContentConfig) return;
    const slides = document.querySelectorAll(".mostage-slide");
    slides.forEach((slide) => {
      const slideElement = slide;
      const isVisible = slideElement.style.display !== "none";
      const contentWrapper = slideElement.querySelector(
        ".mostage-slide-content"
      );
      if (isVisible && contentWrapper) {
        slideElement.classList.add("mostage-slide-centered");
        slideElement.style.display = "flex";
        contentWrapper.style.display = "flex";
        contentWrapper.style.flexDirection = "column";
        if (this.centerContentConfig.vertical && this.centerContentConfig.horizontal) {
          slideElement.style.alignItems = "center";
          slideElement.style.justifyContent = "center";
          contentWrapper.style.alignItems = "center";
          contentWrapper.style.justifyContent = "center";
        } else if (this.centerContentConfig.vertical) {
          slideElement.style.alignItems = "center";
          slideElement.style.justifyContent = "flex-start";
          contentWrapper.style.alignItems = "center";
          contentWrapper.style.justifyContent = "flex-start";
        } else if (this.centerContentConfig.horizontal) {
          slideElement.style.alignItems = "flex-start";
          slideElement.style.justifyContent = "center";
          contentWrapper.style.alignItems = "flex-start";
          contentWrapper.style.justifyContent = "center";
        }
      } else {
        slideElement.classList.remove("mostage-slide-centered");
        if (contentWrapper) {
          contentWrapper.style.display = "block";
          contentWrapper.style.flexDirection = "unset";
          contentWrapper.style.alignItems = "unset";
          contentWrapper.style.justifyContent = "unset";
        }
      }
    });
  }
  cleanup() {
    const slides = document.querySelectorAll(".mostage-slide");
    slides.forEach((slide) => {
      slide.classList.remove("mostage-slide-centered");
    });
  }
}
class UrlHashManager {
  constructor(urlHashEnabled, onSlideChange) {
    this.urlHashEnabled = urlHashEnabled;
    this.onSlideChange = onSlideChange;
  }
  setupUrlHashNavigation() {
    if (!this.urlHashEnabled) return;
    window.addEventListener("hashchange", () => {
      const slideIndex = this.getSlideIndexFromHash();
      if (slideIndex !== -1) {
        this.onSlideChange(slideIndex);
      }
    });
  }
  getInitialSlideFromUrl() {
    if (!this.urlHashEnabled) return 0;
    const slideIndex = this.getSlideIndexFromHash();
    return slideIndex !== -1 ? slideIndex : 0;
  }
  getSlideIndexFromHash() {
    const hash = window.location.hash;
    if (!hash) return -1;
    const match = hash.match(/^#(?:slide-)?(\d+)$/);
    if (match) {
      const slideNumber = parseInt(match[1], 10);
      const slideIndex = slideNumber - 1;
      return slideIndex;
    }
    return -1;
  }
  updateUrlHash(slideIndex, totalSlides) {
    if (!this.urlHashEnabled) return;
    if (slideIndex < 0 || slideIndex >= totalSlides) return;
    const slideNumber = slideIndex + 1;
    const newHash = `#${slideNumber}`;
    if (window.location.hash !== newHash) {
      history.replaceState(null, "", newHash);
    }
  }
}
class Mostage {
  /**
   * Creates a new Mostage presentation instance
   *
   * @param config - Configuration object or path to JSON config file
   * @throws {Error} When container element is not found or invalid
   * @throws {ConfigValidationError} When configuration is invalid
   */
  constructor(config) {
    this.slides = [];
    this.currentSlideIndex = 0;
    this.plugins = [];
    this.eventListeners = /* @__PURE__ */ new Map();
    if (typeof config === "string") {
      this.config = {
        theme: "light",
        transition: {
          type: "horizontal",
          duration: 300,
          easing: "ease-in-out"
        },
        scale: 1,
        loop: false,
        plugins: {},
        keyboard: true,
        touch: true,
        urlHash: false,
        centerContent: {
          vertical: true,
          horizontal: true
        },
        configPath: config
      };
    } else {
      this.config = {
        theme: "light",
        transition: {
          type: "horizontal",
          duration: 300,
          easing: "ease-in-out"
        },
        scale: 1,
        loop: false,
        plugins: {},
        keyboard: true,
        touch: true,
        urlHash: false,
        centerContent: {
          vertical: true,
          horizontal: true
        },
        ...config
      };
    }
    if (typeof this.config.transition === "string") {
      this.config.transition = {
        type: this.config.transition,
        duration: 600,
        easing: "ease-in-out"
      };
    }
    this.syntaxHighlighter = SyntaxHighlighter.getInstance();
    this.container = this.resolveElement(this.config.element || document.body);
    this.container.classList.add("mostage-container");
    this.contentService = new ContentService();
    this.navigationService = new NavigationService(
      this.container,
      this.config.keyboard || false,
      this.config.touch || false,
      (index) => this.goToSlide(index)
    );
    this.overviewManager = new OverviewManager(
      this.container,
      (index) => this.goToSlide(index),
      () => this.onExitOverview(),
      () => this.onEnterOverview()
    );
    this.helpManager = new HelpManager();
    this.centerContentManager = new CenterContentManager(this.container);
    this.initializeConfigDependentManagers();
  }
  /**
   * Initialize managers that depend on configuration values
   */
  initializeConfigDependentManagers() {
    this.transitionManager = new TransitionManager(
      this.container,
      this.config.transition
    );
    this.urlHashManager = new UrlHashManager(
      this.config.urlHash || false,
      (index) => this.goToSlide(index)
    );
  }
  /**
   * Load configuration from a JSON file and merge it with existing config
   * @param configPath Path to the JSON configuration file
   */
  async loadConfigFromFile(configPath) {
    try {
      const response = await fetch(configPath);
      if (!response.ok) {
        throw new Error(
          `Failed to load config file: ${response.status} ${response.statusText}`
        );
      }
      const jsonConfig = await response.json();
      this.config = {
        ...this.config,
        ...jsonConfig
      };
      if (typeof this.config.transition === "string") {
        this.config.transition = {
          type: this.config.transition,
          duration: 300,
          easing: "ease-in-out"
        };
      }
      this.initializeConfigDependentManagers();
    } catch (error) {
      console.error("Failed to load configuration from file:", error);
      throw error;
    }
  }
  /**
   * Initializes and starts the presentation
   *
   * Loads content, applies theme, initializes plugins, and sets up navigation.
   * This method must be called after creating a Mostage instance.
   *
   * @throws {ContentLoadError} When content cannot be loaded
   * @throws {ThemeLoadError} When theme cannot be loaded
   * @throws {PluginLoadError} When plugins fail to load
   *
   * @example
   * ```typescript
   * const presentation = new Mostage(config);
   * await presentation.start();
   * ```
   */
  async start() {
    try {
      if (this.config.configPath) {
        await this.loadConfigFromFile(this.config.configPath);
      }
      if (this.config.theme) {
        await loadTheme(this.config.theme);
      }
      let content;
      if (this.config.content) {
        content = this.config.content;
      } else if (this.config.contentPath) {
        content = await this.contentService.loadContentFromSource(
          this.config.contentPath
        );
      } else {
        throw new Error(
          "No content provided. Please specify content or contentPath."
        );
      }
      this.slides = this.contentService.parseContent(content);
      this.centerContentManager.initialize(this.config.centerContent || null);
      this.navigationService.setSlides(this.slides);
      if (this.config.touch) {
        this.navigationService.enableTouch();
      }
      if (this.config.keyboard) {
        document.addEventListener("keydown", this.handleKeyboard.bind(this));
      }
      this.urlHashManager.setupUrlHashNavigation();
      await this.renderSlides();
      const initialSlide = this.urlHashManager.getInitialSlideFromUrl();
      this.goToSlide(initialSlide);
      this.initializePlugins();
      this.emit("ready", {
        type: "ready",
        currentSlide: this.currentSlideIndex,
        totalSlides: this.slides.length
      });
      this.helpManager.showInitialHelp();
    } catch (error) {
      console.error("Failed to start Mostage:", error);
      throw error;
    }
  }
  resolveElement(element) {
    if (typeof element === "string") {
      const found = document.querySelector(element);
      if (!found) {
        throw new Error(`Element "${element}" not found`);
      }
      return found;
    }
    return element;
  }
  initializePlugins() {
    if (!this.config.plugins) return;
    Object.entries(this.config.plugins).forEach(
      ([pluginName, pluginConfig]) => {
        try {
          const PluginClass = plugins[pluginName];
          if (!PluginClass) {
            console.warn(
              `Plugin "${pluginName}" not found. Available plugins: ${Object.keys(plugins).join(", ")}`
            );
            return;
          }
          const pluginInstance = new PluginClass();
          const finalConfig = pluginConfig || {};
          const isEnabled = finalConfig.enabled === true;
          if (!isEnabled) {
            return;
          }
          if (pluginInstance.setEnabled) {
            pluginInstance.setEnabled(true);
          }
          pluginInstance.init(this, finalConfig);
          this.plugins.push(pluginInstance);
        } catch (error) {
          console.error(`Failed to initialize plugin "${pluginName}":`, error);
        }
      }
    );
  }
  handleKeyboard(event) {
    if (this.overviewManager.isInOverviewMode()) {
      this.overviewManager.handleOverviewKeyboard(event);
      return;
    }
    const key = event.key;
    const keyLower = key.toLowerCase();
    if (this.isNavigationKey(key, keyLower)) {
      event.preventDefault();
      this.handleNavigationKey(key, keyLower);
      return;
    }
    if (this.isModeKey(keyLower)) {
      event.preventDefault();
      this.handleModeKey(keyLower);
      return;
    }
  }
  isNavigationKey(key, keyLower) {
    return key === "ArrowRight" || key === "ArrowLeft" || key === "ArrowUp" || key === "ArrowDown" || key === "Home" || key === "End" || keyLower === " ";
  }
  isModeKey(keyLower) {
    return keyLower === "escape" || keyLower === "o" || keyLower === "h" || keyLower === "?";
  }
  handleNavigationKey(key, keyLower) {
    switch (key) {
      case "ArrowRight":
      case "ArrowDown":
        this.nextSlide();
        break;
      case "ArrowLeft":
      case "ArrowUp":
        this.previousSlide();
        break;
      case "Home":
        this.goToSlide(0);
        break;
      case "End":
        this.goToSlide(this.slides.length - 1);
        break;
    }
    if (keyLower === " ") {
      this.nextSlide();
    }
  }
  handleModeKey(keyLower) {
    switch (keyLower) {
      case "escape":
      case "o":
        this.overviewManager.toggleOverview();
        break;
      case "h":
      case "?":
        this.helpManager.toggleHelp();
        break;
    }
  }
  async renderSlides() {
    this.container.innerHTML = "";
    if (this.config.header) {
      await this.renderHeader();
    }
    if (this.config.footer) {
      await this.renderFooter();
    }
    const slidesContainer = document.createElement("div");
    slidesContainer.className = "mostage-slides";
    this.slides.forEach((slide, index) => {
      const slideElement = document.createElement("div");
      slideElement.className = "mostage-slide";
      slideElement.id = slide.id;
      this.applyBackgroundToSlide(slideElement, index);
      const contentWrapper = document.createElement("div");
      contentWrapper.className = "mostage-slide-content";
      contentWrapper.innerHTML = slide.html;
      if (this.config.scale !== 1) {
        contentWrapper.style.transform = `scale(${this.config.scale})`;
        contentWrapper.style.transformOrigin = "center center";
        if (this.config.scale && this.config.scale > 1) {
          const inverseScale = 1 / this.config.scale;
          contentWrapper.style.width = `${100 * inverseScale}%`;
          contentWrapper.style.height = `${100 * inverseScale}%`;
        }
      }
      slideElement.appendChild(contentWrapper);
      slideElement.style.display = index === 0 ? "block" : "none";
      slidesContainer.appendChild(slideElement);
    });
    this.container.appendChild(slidesContainer);
    this.syntaxHighlighter.highlightAll(this.container);
  }
  applyBackgroundToSlide(slideElement, slideIndex) {
    if (!this.config.background) return;
    const slideNumber = slideIndex + 1;
    const backgrounds = Array.isArray(this.config.background) ? this.config.background : [this.config.background];
    backgrounds.forEach((bg) => {
      if (this.shouldApplyBackground(bg, slideNumber)) {
        this.applyBackgroundStyles(slideElement, bg);
      }
    });
  }
  shouldApplyBackground(bg, slideNumber) {
    if (bg.global === true) {
      return true;
    }
    if (bg.allSlides && bg.allSlides.length > 0) {
      if (bg.allSlides.includes(slideNumber)) {
        return true;
      }
    }
    if (bg.allSlidesExcept && bg.allSlidesExcept.length > 0) {
      if (!bg.allSlidesExcept.includes(slideNumber)) {
        return true;
      }
    }
    return false;
  }
  applyBackgroundStyles(slideElement, bg) {
    if (bg.bgColor) {
      slideElement.style.backgroundColor = bg.bgColor;
    }
    if (bg.imagePath) {
      slideElement.style.backgroundImage = `url("${bg.imagePath}")`;
      slideElement.style.backgroundSize = bg.size || "cover";
      slideElement.style.backgroundPosition = bg.position || "center";
      slideElement.style.backgroundRepeat = bg.repeat || "no-repeat";
    }
  }
  async renderHeader() {
    if (!this.config.header) return;
    const headerElement = document.createElement("div");
    headerElement.className = "mostage-header";
    const position = this.config.header.position || "top-center";
    headerElement.classList.add(`mostage-header-${position.replace("-", "-")}`);
    let content = "";
    if (this.config.header.content) {
      content = this.config.header.content;
    } else if (this.config.header.contentPath) {
      try {
        content = await this.contentService.loadContentFromSource(
          this.config.header.contentPath
        );
      } catch (error) {
        console.error("Failed to load header content:", error);
        return;
      }
    }
    if (content) {
      if (content.includes("#") || content.includes("*") || content.includes("`")) {
        const parsedContent = this.contentService.parseMarkdownToHtml(content);
        headerElement.innerHTML = parsedContent;
      } else {
        headerElement.innerHTML = content;
      }
    }
    this.container.appendChild(headerElement);
    if (this.currentSlideIndex === 0 && this.config.header.showOnFirstSlide !== true) {
      headerElement.style.display = "none";
    }
  }
  async renderFooter() {
    if (!this.config.footer) return;
    const footerElement = document.createElement("div");
    footerElement.className = "mostage-footer";
    const position = this.config.footer.position || "bottom-left";
    footerElement.classList.add(`mostage-footer-${position.replace("-", "-")}`);
    let content = "";
    if (this.config.footer.content) {
      content = this.config.footer.content;
    } else if (this.config.footer.contentPath) {
      try {
        content = await this.contentService.loadContentFromSource(
          this.config.footer.contentPath
        );
      } catch (error) {
        console.error("Failed to load footer content:", error);
        return;
      }
    }
    if (content) {
      if (content.includes("#") || content.includes("*") || content.includes("`")) {
        const parsedContent = this.contentService.parseMarkdownToHtml(content);
        footerElement.innerHTML = parsedContent;
      } else {
        footerElement.innerHTML = content;
      }
    }
    this.container.appendChild(footerElement);
    if (this.currentSlideIndex === 0 && this.config.footer.showOnFirstSlide !== true) {
      footerElement.style.display = "none";
    }
  }
  updateHeaderFooterVisibility() {
    if (this.config.header) {
      const headerElement = this.container.querySelector(
        ".mostage-header"
      );
      if (headerElement) {
        if (this.currentSlideIndex === 0 && this.config.header.showOnFirstSlide !== true) {
          headerElement.style.display = "none";
        } else {
          headerElement.style.display = "block";
        }
      }
    }
    if (this.config.footer) {
      const footerElement = this.container.querySelector(
        ".mostage-footer"
      );
      if (footerElement) {
        if (this.currentSlideIndex === 0 && this.config.footer.showOnFirstSlide !== true) {
          footerElement.style.display = "none";
        } else {
          footerElement.style.display = "block";
        }
      }
    }
  }
  nextSlide() {
    if (this.currentSlideIndex < this.slides.length - 1) {
      this.goToSlide(this.currentSlideIndex + 1);
    } else if (this.config.loop) {
      this.goToSlide(0);
    }
  }
  previousSlide() {
    if (this.currentSlideIndex > 0) {
      this.goToSlide(this.currentSlideIndex - 1);
    } else if (this.config.loop) {
      this.goToSlide(this.slides.length - 1);
    }
  }
  goToSlide(index) {
    if (index < 0 || index >= this.slides.length) return;
    const previousIndex = this.currentSlideIndex;
    this.currentSlideIndex = index;
    this.urlHashManager.updateUrlHash(index, this.slides.length);
    if (previousIndex === index) {
      this.transitionManager.showSlide(index);
    } else {
      this.transitionManager.animateTransition(previousIndex, index);
    }
    this.centerContentManager.onSlideChange();
    this.updateHeaderFooterVisibility();
    this.navigationService.setCurrentSlideIndex(index);
    this.overviewManager.setCurrentSlideIndex(index);
    this.emit("slidechange", {
      type: "slidechange",
      currentSlide: index,
      totalSlides: this.slides.length,
      slide: this.slides[index]
    });
  }
  onEnterOverview() {
    this.helpManager.hideForOverview();
  }
  onExitOverview() {
    this.helpManager.restoreAfterOverview();
  }
  // Event system
  on(event, callback) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event).push(callback);
  }
  emit(event, data) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.forEach((callback) => callback(data));
    }
  }
  // Getters for plugins
  /**
   * Gets the current slide index (0-based)
   * @returns Current slide index
   */
  getCurrentSlide() {
    return this.currentSlideIndex;
  }
  /**
   * Gets the total number of slides
   * @returns Total number of slides
   */
  getTotalSlides() {
    return this.slides.length;
  }
  /**
   * Gets all slides
   * @returns Array of all slides
   */
  getSlides() {
    return this.slides;
  }
  /**
   * Gets the presentation container element
   * @returns The container HTMLElement
   */
  getContainer() {
    return this.container;
  }
  // Overview control
  toggleOverview() {
    this.overviewManager.toggleOverview();
  }
  // Cleanup
  destroy() {
    this.plugins.forEach((plugin) => {
      try {
        if (plugin.destroy) {
          plugin.destroy();
        }
      } catch (error) {
        console.error(`Failed to destroy plugin: ${plugin.name}`, error);
      }
    });
    this.plugins = [];
    this.eventListeners.clear();
    this.navigationService.destroy();
    this.contentService.clearCache();
    this.centerContentManager.cleanup();
  }
}
const _ConfigService = class _ConfigService {
  /**
   * Load configuration from file
   */
  async loadFromFile(path) {
    try {
      const response = await fetch(path);
      if (!response.ok) {
        throw new ConfigLoadError(
          `Failed to load config from ${path}: ${response.status} ${response.statusText}`,
          path,
          response.status
        );
      }
      const configData = await response.json();
      return this.validateAndMerge(configData);
    } catch (error) {
      if (error instanceof ConfigLoadError) {
        throw error;
      }
      throw new ConfigLoadError(
        `Error loading config from ${path}: ${error instanceof Error ? error.message : "Unknown error"}`,
        path
      );
    }
  }
  /**
   * Load configuration from URL
   */
  async loadFromURL(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new ConfigLoadError(
          `Failed to load config from ${url}: ${response.status} ${response.statusText}`,
          url,
          response.status
        );
      }
      const configData = await response.json();
      return this.validateAndMerge(configData);
    } catch (error) {
      if (error instanceof ConfigLoadError) {
        throw error;
      }
      throw new ConfigLoadError(
        `Error loading config from ${url}: ${error instanceof Error ? error.message : "Unknown error"}`,
        url
      );
    }
  }
  /**
   * Load configuration from object
   */
  loadFromObject(obj) {
    try {
      return this.validateAndMerge(obj);
    } catch (error) {
      throw new ConfigValidationError(
        `Invalid configuration object: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Validate configuration
   */
  validate(config) {
    const errors = [];
    const warnings = [];
    if (!config || typeof config !== "object") {
      errors.push("Configuration must be an object");
      return { isValid: false, errors, warnings };
    }
    if (config.theme && typeof config.theme !== "string") {
      errors.push("Theme must be a string");
    }
    if (config.scale !== void 0) {
      if (typeof config.scale !== "number" || config.scale <= 0) {
        errors.push("Scale must be a positive number");
      }
    }
    if (config.transition) {
      if (typeof config.transition === "string") {
        warnings.push("Transition as string is deprecated, use object format");
      } else if (typeof config.transition === "object") {
        if (config.transition.type && !["horizontal", "vertical", "fade", "slide"].includes(
          config.transition.type
        )) {
          errors.push("Invalid transition type");
        }
        if (config.transition.duration && (typeof config.transition.duration !== "number" || config.transition.duration < 0)) {
          errors.push("Transition duration must be a non-negative number");
        }
      }
    }
    if (config.plugins && typeof config.plugins !== "object") {
      errors.push("Plugins must be an object");
    }
    const booleanProps = ["loop", "keyboard", "touch", "urlHash"];
    booleanProps.forEach((prop) => {
      if (config[prop] !== void 0 && typeof config[prop] !== "boolean") {
        errors.push(`${prop} must be a boolean`);
      }
    });
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * Validate required fields
   */
  validateRequired(config, required) {
    const errors = [];
    const warnings = [];
    required.forEach((field) => {
      if (!(field in config)) {
        errors.push(`Required field '${field}' is missing`);
      }
    });
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * Validate field types
   */
  validateTypes(config, schema) {
    const errors = [];
    const warnings = [];
    Object.entries(schema).forEach(([field, expectedType]) => {
      if (field in config) {
        const actualType = typeof config[field];
        if (actualType !== expectedType) {
          errors.push(
            `Field '${field}' must be of type ${expectedType}, got ${actualType}`
          );
        }
      }
    });
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * Get default configuration
   */
  getDefaultConfig() {
    return { ..._ConfigService.defaultConfig };
  }
  /**
   * Merge configuration with defaults
   */
  validateAndMerge(config) {
    const validation = this.validate(config);
    if (!validation.isValid) {
      throw new ConfigValidationError(
        `Configuration validation failed: ${validation.errors.join(", ")}`
      );
    }
    if (validation.warnings.length > 0) {
      console.warn("Configuration warnings:", validation.warnings);
    }
    return this.deepMerge(_ConfigService.defaultConfig, config);
  }
  /**
   * Deep merge objects
   */
  deepMerge(target, source) {
    const result = { ...target };
    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        if (source[key] && typeof source[key] === "object" && !Array.isArray(source[key])) {
          result[key] = this.deepMerge(target[key] || {}, source[key]);
        } else {
          result[key] = source[key];
        }
      }
    }
    return result;
  }
};
_ConfigService.defaultConfig = {
  theme: "light",
  transition: {
    type: "horizontal",
    duration: 300,
    easing: "ease-in-out"
  },
  scale: 1,
  loop: false,
  plugins: {},
  keyboard: true,
  touch: true,
  urlHash: false,
  centerContent: {
    vertical: true,
    horizontal: true
  }
};
let ConfigService = _ConfigService;
class ConfigError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = this.constructor.name;
  }
}
class ConfigLoadError extends ConfigError {
  constructor(message, path, statusCode) {
    super(message, "CONFIG_LOAD_ERROR");
    this.path = path;
    this.statusCode = statusCode;
  }
}
class ConfigValidationError extends ConfigError {
  constructor(message) {
    super(message, "CONFIG_VALIDATION_ERROR");
  }
}
export {
  CenterContentManager,
  ConfettiPlugin,
  ConfigService,
  ContentService,
  ControllerPlugin,
  HelpManager,
  MarkdownParser,
  Mostage,
  NavigationService,
  OverviewManager,
  PluginBase,
  PluginService,
  ProgressBarPlugin,
  SlideNumberPlugin,
  SyntaxHighlighter,
  ThemeService,
  TransitionManager,
  UrlHashManager,
  Mostage as default,
  getAvailableThemes,
  loadTheme,
  plugins,
  themes
};
//# sourceMappingURL=index.js.map

const mostage = new Mostage(config);
mostage.start();</script>
  </body>
</html>
